<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <p>This blog post is adapted from ex-OpenAI researcher, Anthropicco-founder &lt;ahref="https://colah.github.io/posts/2015-09-Visual-Information/"&gt;ChristopherOlah’s wonderful work&lt;/a&gt;. I removed parts that are generallycommonsense to a CS kid and added some of my own notes &amp;explanations.</p> <p><span id="more"></span>&lt;h2 id="visualizing-probability-distribution"&gt;Visualizing ProbabilityDistribution&lt;/h2&gt;&lt;p&gt;The author did a really cool job visualizing probability distributionhere, but doesn’t provide any more knowledge than basic probabilitytheory, so removed this part.&lt;/p&gt;&lt;h2 id="code"&gt;Code&lt;/h2&gt;&lt;p&gt;I want to communicate with my friend Bob, so we establish a code,mapping each possible word we may say to sequences of bits.&lt;/p&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/code-2bit.png”alt=”fixed length code” /&gt;&lt;figcaption aria-hidden="true"&gt;fixed length code&lt;/figcaption&gt;</figure>&lt;p&gt;However, Bob is a dog lover, with very high probability, he talksabout dogs.&lt;/p&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/DogWordFreq.png”alt=”Bob’s word frequency” /&gt;&lt;figcaption aria-hidden="true"&gt;Bob’s word frequency&lt;/figcaption&gt;</figure>&lt;p&gt;Incorporating the code we defined above into this graph, we get thefollowing diagram, with the vertical axis to visualize the probabilityof each word, <span class="math inline"><em>p</em>(<em>x</em>)</span>,and the horizontal axis to visualize the length of the correspondingcodeword, <span class="math inline"><em>L</em>(<em>x</em>)</span>.Notice the total area is the expected length of a codeword we send.&lt;/p&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/OldCode.png”alt=”Expected length of fixed-length code” /&gt;&lt;figcaption aria-hidden="true"&gt;Expected length of fixed-lengthcode&lt;/figcaption&gt;</figure>&lt;h2 id="variable-length-code"&gt;Variable-Length Code&lt;/h2&gt;&lt;p&gt;Perhaps we could be very clever and make a variable-length code wherecodewords for common words are made especially short. The challenge isthat there’s competition between codewords – making some shorter forcesus to make others longer. To minimize the message length, we especiallywant the commonly used ones to be. So the resulting code has shortercodewords for common words (like “dog”) and longer codewords for lesscommon words (like “bird”).&lt;/p&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/code.png”alt=”Variable length code” /&gt;&lt;figcaption aria-hidden="true"&gt;Variable length code&lt;/figcaption&gt;</figure>&lt;p&gt;Looking at this code format with word frequency, on average, thelength of a codeword is now 1.75 bits!&lt;/p&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/NewCode.png”alt=”Expected length of variable-length code” /&gt;&lt;figcaption aria-hidden="true"&gt;Expected length of variable-lengthcode&lt;/figcaption&gt;</figure>&lt;p&gt;It turns out that this code is the best possible code. There is nocode which, for this word frequency distribution, will give us anaverage codeword length of less than 1.75 bits.&lt;/p&gt;&lt;p&gt;There is simply a fundamental limit. Communicating what word wassaid, what event from this distribution occurred, requires us tocommunicate at least 1.75 bits on average. No matter how clever ourcode, it’s impossible to get the average message length to be less. Wecall this fundamental limit the <strong>entropy</strong> of thedistribution – we’ll discuss it in much more detail shortly.&lt;/p&gt;&lt;h2 id="the-space-of-codewords"&gt;The Space of Codewords&lt;/h2&gt;&lt;p&gt;To make our codewords uniquely decodable, we want them to follow the<em>prefix property</em>: no codeword should be the prefix of anothercodeword. i.e. If we see a particular codeword, there shouldn’t be somelonger version that is also a codeword. Codes that obey this propertyare also called <em>prefix codes</em>.&lt;/p&gt;&lt;p&gt;One useful way to think about this is that every codeword requires asacrifice from the space of possible codewords. If we take the codeword01, we lose the ability to use any codewords it’s a prefix of. We can’tuse 010 or 011010110 anymore because of ambiguity – they’re lost to us.The following graph shows we in effect lost &lt;spanclass=”math inline”&gt;$\frac {1} {2^{L(01)}} = \frac {1} {2^2} = \frac {1}{4}$&lt;/span&gt; of our codeword space.&lt;/p&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/CodeSpaceUsed.png”alt=”Code space sacrificed” /&gt;&lt;figcaption aria-hidden="true"&gt;Code space sacrificed&lt;/figcaption&gt;</figure>&lt;p&gt;Since a quarter of all codewords start with 01, we’ve sacrificed aquarter of all possible codewords. That’s the price we pay in exchangefor having one codeword that’s only 2 bits long! In turn this sacrificemeans that all the other codewords need to be a bit longer. There’salways this sort of trade off between the lengths of the differentcodewords. A short codeword requires you to sacrifice more of the spaceof possible codewords, preventing other codewords from being short. Whatwe need to figure out is what the right trade off to make is!&lt;/p&gt;&lt;h2 id="cost-of-codeword"&gt;Cost of Codeword&lt;/h2&gt;&lt;p&gt;You can think of this like having a limited budget to spend ongetting short codewords. In fact, we have a budget = 1 to spend, where 1is the area of the whole codeword space. We pay for one codeword bysacrificing a fraction of possible codewords.&lt;/p&gt;&lt;p&gt;We define the cost <span class="math inline"><em>c</em></span> ofhaving a code word <span class="math inline"><em>x</em></span> withlength <span class="math inline"><em>L</em></span> as &lt;spanclass=”math inline”&gt;$\frac 1 {2^{L(x)}}$&lt;/span&gt;.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The cost of buying a codeword of length 0 is 1, all possiblecodewords – if you want to have a codeword of length 0, you can’t haveany other codeword. <span class="math inline">$x = \emptyset, c = \frac1 {2^{L(\emptyset)}} = \frac 1 {2^0}$</span>&lt;/li&gt;&lt;li&gt;The cost of a codeword of length 1, like “0”, is 1/2 because half ofpossible codewords start with “0”. <span class="math inline">$x = 0, c =\frac 1 {2^{L(“0”)}} = \frac 1 {2^1}$</span>&lt;/li&gt;&lt;li&gt;The cost of a codeword of length 2, like “01”, is 1/4 because aquarter of all possible codewords start with “01” &lt;spanclass=”math inline”&gt;$x = 0, c = \frac 1 {2^{L(“01”)}} = \frac 1{2^2}$&lt;/span&gt;&lt;/li&gt;&lt;li&gt;…&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;(ignore the gray area in the following graph, the function we plot is<span class="math inline">$\frac 1 {2^L}$</span> and cost is theheight)&lt;/p&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/code-costonly.png”alt=”Code cost” /&gt;&lt;figcaption aria-hidden="true"&gt;Code cost&lt;/figcaption&gt;</figure>&lt;p&gt;To make the calculation simpler, instead of base 2, we imagine wehave the natural number e. It now is no longer a binary code, but a“natural” code with the cost becomes <span class="math inline">$\frac 1{e^L}$</span>. It is both the height and the gray area: &lt;spanclass=”math inline”&gt;$\frac 1 {e^L} = \int^\infty_L \frac 1 {e^L} \;dL$&lt;/span&gt;&lt;/p&gt;&lt;h2 id="optimal-encoding"&gt;Optimal Encoding&lt;/h2&gt;&lt;p&gt;Recall the expected length of the codeword we pictured above, if welook at each codeword’s contribution to this expected length, eachcodeword makes the average message length longer by its probabilitytimes the length of the codeword. For example, if we need to send acodeword that is 4 bits long 50% of the time, our average message lengthis 2 bits longer than it would be if we weren’t sending that codeword.We can picture this as a rectangle.&lt;/p&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/code-lengthcontrib.png”alt=”Contribution to expected length” /&gt;&lt;figcaption aria-hidden="true"&gt;Contribution to expectedlength&lt;/figcaption&gt;</figure>&lt;p&gt;Now, we have two values related to the length of a codeword and wepicture them together in the following graph:&lt;/p&gt;&lt;ol type="1"&gt;&lt;li&gt;The amount we pay decides the length of the codeword: gray partdecides the width of the purple rectangle&lt;/li&gt;&lt;li&gt;The length of the codeword controls how much it adds to the averagemessage length: width of the rec decides the area of the rec (height isfixed for a given word because height represents the wordfrequency)&lt;/li&gt;&lt;/ol&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/code-cost.png”alt=”Contribution and cost” /&gt;&lt;figcaption aria-hidden="true"&gt;Contribution and cost&lt;/figcaption&gt;</figure>&lt;p&gt;Short codewords reduce the average message length but are expensive,while long codewords increase the average message length but arecheap.&lt;/p&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/code-cost-longshort.png”alt=”short vs long” /&gt;&lt;figcaption aria-hidden="true"&gt;short vs long&lt;/figcaption&gt;</figure>&lt;p&gt;What’s the best way to use our limited budget? Just like one wants toinvest more in tools that one uses regularly, we want to spend more onfrequently used codewords. There’s one particularly natural way to dothis: <strong>distribute our budget in proportion to how common an eventis - &lt;spanclass=”math inline”&gt;<em>c</em>(<em>x</em>) = <em>p</em>(<em>x</em>)&lt;/span&gt;</strong>.The following graph shows such encoding system.&lt;/p&gt;&lt;p&gt;Additionally, that’s exactly what we did in our codes with Bob: “dog”appears <span class="math inline">$\frac 1 2$</span> of the time, so wegive it codeword “0” with the cost <span class="math inline">$c = \frac1 {2^{L(“0”)}} = \frac 1 {2^1}$</span>; “bird” appears &lt;spanclass=”math inline”&gt;$\frac 1 8$&lt;/span&gt; of the time, so we give itcodeword “111” with the cost <span class="math inline">$c = \frac 1{2^{L(“111”)}} = \frac 1 {2^3}$</span>; If an event only happens 1% ofthe time, we only spend 1% of our budget.&lt;/p&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/code-auction-balanced-noderivs.png”alt=”Contribution and cost line up” /&gt;&lt;figcaption aria-hidden="true"&gt;Contribution and cost lineup&lt;/figcaption&gt;</figure>&lt;p&gt;The author then proved it is the optimal thing to do. Honestly Ididn’t understand the proof, but this code system we’re talking abouthere is no more than a general version of Huffman Encoding. So I guessit’s fine as long as you understand how to prove the greedy HuffmanEncoding is optimal.&lt;/p&gt;&lt;h2 id="calculating-entropy"&gt;Calculating Entropy&lt;/h2&gt;&lt;p&gt;In the <a href="#cost-of-codeword">Cost of Codeword</a> section, wedefined the cost <span class="math inline"><em>c</em></span> of having acode word <span class="math inline"><em>x</em></span> with length &lt;spanclass=”math inline”&gt;<em>L</em>&lt;/span&gt; as &lt;spanclass=”math inline”&gt;$\frac 1 {2^{L(x)}}$&lt;/span&gt;. By inverting thisdefinition, given <span class="math inline"><em>c</em></span>, we caninfer the length <span class="math inline">$L(x) = \log_2 \frac 1c$</span>&lt;/p&gt;&lt;p&gt;Furthermore, in the <a href="#optimial-encoding">Optimal Encoding</a>section, we proved the optimal cost to spend on each word is &lt;spanclass=”math inline”&gt;<em>c</em>(<em>x</em>) = <em>p</em>(<em>x</em>)&lt;/span&gt;,so the length of the optimal encoding system is &lt;spanclass=”math inline”&gt;$L(x) = \log_2 \frac 1 {p(x)}$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Earlier, we said: given a probability distribution of what we want tocommunicate, there is a fundamental limit of expected code length weneed to send no matter how smart our code is. This limit, the expectedcode length using the best possible code, is called the<strong>entropy</strong> of <span class="math inline"><em>p</em></span>:<span class="math inline"><em>H</em>(<em>p</em>)</span>.&lt;/p&gt;&lt;p&gt;<span class="math display">\(H(p) = \mathbb{E}_{p(x)} [L(x)] = \sum_x p(x) \log_2 \frac 1 {p(x)}\)</span>&lt;/p&gt;&lt;p&gt;People usually write entropy in the following way, which makes itmuch less intuitive.&lt;/p&gt;&lt;p&gt;&lt;spanclass=”math display”&gt;<em>H</em>(<em>p</em>) = −∑<sub><em>x</em></sub><em>p</em>(<em>x</em>)log<sub>2</sub><em>p</em>(<em>x</em>)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;The entropy, which by definition is the shortest possible code, hasclear implications for compression. In addition, it describes howuncertain I am and gives a way to quantify information:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;If I knew for sure what was going to happen, I wouldn’t have to senda message at all! &lt;spanclass=”math inline”&gt;<em>p</em>(<em>x</em>) = 1 ⟹ <em>H</em>(<em>x</em>) = 0&lt;/span&gt;&lt;/li&gt;&lt;li&gt;If there’s two things that could happen with 50% probability, I onlyneed to send 1 bit. &lt;spanclass=”math inline”&gt;∀<em>x</em><sub><em>i</em></sub>, <em>p</em>(<em>x</em><sub><em>i</em></sub>) = 0.5 ⟹ <em>H</em>(<em>x</em>) = 1&lt;/span&gt;&lt;/li&gt;&lt;li&gt;If there’s 64 different things that could happen with equalprobability, I’d have to send 6 bits. <span class="math inline">$\forallx_i, p(x_i) = \frac 1 {64} \implies H(x) = 6$</span>&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The more concentrated the probability, the more I can craft a clevercode with short average messages. The more diffuse the probability, thelonger my messages have to be.&lt;/p&gt;&lt;h2 id="cross-entropy"&gt;Cross Entropy&lt;/h2&gt;&lt;p&gt;Imagine now a cat-lover Alice talks about animals with the followingword frequency:&lt;/p&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/DogCatWordFreq.png”alt=”Alice loves cats” /&gt;&lt;figcaption aria-hidden="true"&gt;Alice loves cats&lt;/figcaption&gt;</figure>&lt;p&gt;When Alice sends a message to Bob using Bob’s codes, her messageswere longer than they needed to be. Bob’s code was optimized to hisprobability distribution. Alice has a different probabilitydistribution, and the code is suboptimal for it: the expected codewordlength when Bob uses his own code is 1.75 bits, while when Alice useshis code it’s 2.25. It would be worse if the two weren’t so similar!&lt;/p&gt;&lt;p&gt;The expected length of communicating an event from distribution &lt;spanclass=”math inline”&gt;<em>q</em>(<em>x</em>)&lt;/span&gt; with the optimal codefor another distribution &lt;spanclass=”math inline”&gt;<em>p</em>(<em>x</em>)&lt;/span&gt; is called the<strong>cross-entropy</strong>. Formally, we define cross-entropy as:(people usually write &lt;spanclass=”math inline”&gt;<em>H</em>(<em>q</em>, <em>p</em>)&lt;/span&gt;instead)&lt;/p&gt;&lt;p&gt;<span class="math display">\(H_p(q) = \mathbb E_{q} \log_2\left(\frac{1}{p(x)}\right)= \sum_xq(x)\log_2\left(\frac{1}{p(x)}\right)\)</span>&lt;/p&gt;&lt;p&gt;To lower the cost of Alice sending message, I asked both of them tonow use Alice’s coding, but this made it suboptimal for Bob andsurprisingly, it’s worse for Bob to use Alice’s code than for Alice touse his! <strong>Cross-entropy isn’t symmetric.</strong>&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Bob using his own code (&lt;spanclass=”math inline”&gt;<em>H</em>(<em>p</em>) = 1.75&lt;/span&gt; bits)&lt;/li&gt;&lt;li&gt;Alice using Bob’s code (&lt;spanclass=”math inline”&gt;<em>H</em><sub><em>p</em></sub>(<em>q</em>) = 2.25&lt;/span&gt; bits)&lt;/li&gt;&lt;li&gt;Alice using her own code (&lt;spanclass=”math inline”&gt;<em>H</em>(<em>q</em>) = 1.75&lt;/span&gt; bits)&lt;/li&gt;&lt;li&gt;Bob using Alice’s code (&lt;spanclass=”math inline”&gt;<em>H</em><sub><em>q</em></sub>(<em>p</em>) = 2.375&lt;/span&gt; bits)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;In the following diagram, if the messages are coming from the samedistribution the plots are beside each other, and if they use the samecodes they are on top of each other. This allows you to kind of visuallyslide the distributions and codes together.&lt;/p&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/CrossEntropyCompare.png”alt=”4 cases of cross entropy” /&gt;&lt;figcaption aria-hidden="true"&gt;4 cases of cross entropy&lt;/figcaption&gt;</figure>&lt;p&gt;So why one is bigger than the other? This is because When Bob usesAlice’s code &lt;spanclass=”math inline”&gt;<em>H</em><sub><em>q</em></sub>(<em>p</em>)&lt;/span&gt;,Bob says “dog” with high probability but “dog” is a word Alice happensto say the least so assigned longest length to. On the other hand for&lt;spanclass=”math inline”&gt;<em>H</em><sub><em>p</em></sub>(<em>q</em>)&lt;/span&gt;,Bob didn’t dislike “cats” that much, so didn’t assign it with too big aword length.&lt;/p&gt;&lt;h2 id="kl-divergence"&gt;KL Divergence&lt;/h2&gt;&lt;p&gt;Cross-entropy gives us a way to express how different two probabilitydistributions are. When using &lt;spanclass=”math inline”&gt;<em>q</em>&lt;/span&gt;’s codewords for &lt;spanclass=”math inline”&gt;<em>p</em>&lt;/span&gt;’s distribution, the more differentthe distributions <span class="math inline"><em>p</em></span> and &lt;spanclass=”math inline”&gt;<em>q</em>&lt;/span&gt; are, the bigger the difference isbetween cross-entropy of &lt;spanclass=”math inline”&gt;<em>p</em>&lt;/span&gt; with respect to &lt;spanclass=”math inline”&gt;<em>q</em>&lt;/span&gt; and the entropy of &lt;spanclass=”math inline”&gt;<em>p</em>&lt;/span&gt;. In math, &lt;spanclass=”math inline”&gt;<em>D</em><sub><em>q</em></sub>(<em>p</em>) = <em>H</em><sub><em>q</em></sub>(<em>p</em>) − <em>H</em>(<em>p</em>)&lt;/span&gt;is bigger.&lt;/p&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/CrossEntropyQP.png”alt=”H_q(p)” /&gt;&lt;figcaption aria-hidden="true"&gt;H_q(p)&lt;/figcaption&gt;</figure>&lt;p&gt;Similarly when using <span class="math inline"><em>p</em></span>’scodewords for <span class="math inline"><em>q</em></span>’sdistribution.&lt;/p&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/CrossEntropyPQ.png”alt=”H_p(q)” /&gt;&lt;figcaption aria-hidden="true"&gt;H_p(q)&lt;/figcaption&gt;</figure>&lt;p&gt;The really interesting thing is the difference &lt;spanclass=”math inline”&gt;<em>D</em><sub><em>q</em></sub>(<em>p</em>)&lt;/span&gt;.That difference is how much longer our messages are because we used acode optimized for a different distribution &lt;spanclass=”math inline”&gt;<em>q</em>&lt;/span&gt;. If the distributions are thesame, this difference will be zero. As the difference grows, it will getbigger.&lt;/p&gt;&lt;p&gt;This difference is the <strong>Kullback–Leibler divergence</strong>,or just the <strong>KL divergence</strong>. The really neat thing aboutKL divergence is that it’s like a distance between two distributions. Itmeasures how different they are! (If you take that idea seriously, youend up with information geometry)&lt;/p&gt;&lt;p&gt;People usually write it as &lt;spanclass=”math inline”&gt;<em>D</em><em>L</em><sub><em>K</em></sub>(<em>p</em>||<em>q</em>)&lt;/span&gt;,but our more intuitive way writes:&lt;/p&gt;&lt;p&gt;&lt;spanclass=”math display”&gt;<em>D</em><sub><em>q</em></sub>(<em>p</em>) = <em>H</em><sub><em>q</em></sub>(<em>p</em>) − <em>H</em>(<em>p</em>)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;If you expand the definition of KL divergence, you get:&lt;/p&gt;&lt;p&gt;<span class="math display">\(\begin{align}D_q(p) &amp;amp;= \sum_x p(x)\log_2\left(\frac{p(x)}{q(x)} \right) \\&amp;amp;= \sum_x p(x) \left[ \log_2\left(\frac{1}{q(x)} \right) -\log_2\left(\frac{1}{p(x)} \right)\right]\\&amp;amp;= \sum_x p(x) \left[ L_q(x) - L_p(x)\right]\end{align}\)</span>&lt;/p&gt;&lt;p&gt;And we see the &lt;spanclass=”math inline”&gt;$\log_2\left(\frac{p(x)}{q(x)} \right)$&lt;/span&gt; issimply the difference between how many bits a code optimized for &lt;spanclass=”math inline”&gt;<em>q</em>&lt;/span&gt; and a code optimized for &lt;spanclass=”math inline”&gt;<em>p</em>&lt;/span&gt; would use to represent &lt;spanclass=”math inline”&gt;<em>x</em>&lt;/span&gt;. The expression as a whole is theexpected difference in how many bits the two codes would use&lt;/p&gt;&lt;h2 id="multiple-variables-and-joint-entropy"&gt;Multiple Variables andJoint Entropy&lt;/h2&gt;&lt;p&gt;Let’s return to our weather and clothing example from earlier. Mymother, like many parents, worries that I don’t dress appropriately forthe weather. So, she often wants to know both the weather and whatclothing I’m wearing. How many bits do I have to send her to communicatethis?&lt;/p&gt;&lt;p&gt;To send both pieces of information, we can flatten the probabilitydistribution (calculate the <strong>joint probability</strong>)&lt;/p&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/prob-2D-factored1-flat.png”alt=”flattened probability” /&gt;&lt;figcaption aria-hidden="true"&gt;flattened probability&lt;/figcaption&gt;</figure>&lt;p&gt;Now we can figure out the optimal codewords for events of theseprobabilities and compute the average message length:&lt;/p&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/Hxy-flat.png”alt=”joint word length” /&gt;&lt;figcaption aria-hidden="true"&gt;joint word length&lt;/figcaption&gt;</figure>&lt;p&gt;Everything is the exact same as our normal definition, except withtwo variables instead of one. We call this the <strong>jointentropy</strong> of &lt;spanclass=”math inline”&gt;<em>X</em>&lt;/span&gt; and &lt;spanclass=”math inline”&gt;<em>Y</em>&lt;/span&gt;, defined as&lt;/p&gt;&lt;p&gt;<span class="math display">\(H(X,Y) = \mathbb E_{p(x,y)} \log_2\left(\frac{1}{p(x,y)}\right) =\sum_{x,y} p(x,y) \log_2\left(\frac{1}{p(x,y)}\right)\)</span>&lt;/p&gt;&lt;p&gt;It’s in fact more intuitive not to flatten it, but Instead to keepthe 2 dimensional square and add word length as a 3rd dimension height.Now the entropy is the volume.&lt;/p&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/Hxy-3D.png”alt=”3D code length” /&gt;&lt;figcaption aria-hidden="true"&gt;3D code length&lt;/figcaption&gt;</figure>&lt;h2 id="conditional-entropy"&gt;Conditional Entropy&lt;/h2&gt;&lt;p&gt;Suppose my mom already knows the weather. She can check it on thenews. Now how much information do I need to provide? I actually need tosend less, because the weather strongly implies what clothing I’llwear!&lt;/p&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/HxCy-sep.png”alt=”Conditional code length separated” /&gt;&lt;figcaption aria-hidden="true"&gt;Conditional code lengthseparated&lt;/figcaption&gt;</figure>&lt;p&gt;When it’s sunny, I can use a special sunny-optimized code, and whenit’s raining I can use a raining optimized code. In both cases, I sendless information than if I used a generic code for both. For example incase of raining, I send code length of 4 when I wear t-shirt and codelength of 4/3 when I wear coat.&lt;/p&gt;&lt;p&gt;<span class="math display">\(H(X \mid \text{Y = raining})= \frac 1 4 \log_2 \frac 1 4 + \frac 3 4 \log_2 \frac 3 4= 0.81\)</span>&lt;/p&gt;&lt;p&gt;(Don’t worry for now why the entropy, representing length of anoptimal codeword, can be fractional, we will &lt;ahref=”#fractional-bits”&gt;explain it later&lt;/a&gt;)&lt;/p&gt;&lt;p&gt;With a similar calculation, we show &lt;spanclass=”math inline”&gt;<em>H</em>(<em>X</em> ∣ Y = sunny) = 0.81&lt;/span&gt;. Toget the average amount of information I need to send my mother, I justput these two cases together:&lt;/p&gt;&lt;p&gt;<span class="math display">\(\begin{align}H(X \mid Y) &amp;amp;= P(\text{Y = rainy})\,H(X \mid \text{Y = rainy})+P(\text{Y = sunny})\,H(X \mid \text{Y = sunny}) \\&amp;amp;= \frac 1 4 \times 0.81 + \frac 3 4 \times 0.81 = 0.81\end{align}\)</span>&lt;/p&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/HxCy.png”alt=”Conditional code length together” /&gt;&lt;figcaption aria-hidden="true"&gt;Conditional code lengthtogether&lt;/figcaption&gt;</figure>&lt;p&gt;We call this the <strong>conditional entropy</strong>:&lt;/p&gt;&lt;p&gt;<span class="math display">\(\begin{align}H(X|Y) &amp;amp;= \sum_y p(y) H(X \mid Y=y) \\&amp;amp;= \sum_y p(y) \sum_x p(x|y) \log_2\left(\frac{1}{p(x|y)}\right) \\&amp;amp;= \sum_{x,y} p(x,y) \log_2\left(\frac{1}{p(x|y)}\right)\end{align}\)</span>&lt;/p&gt;&lt;h2 id="mutual-information"&gt;Mutual Information&lt;/h2&gt;&lt;p&gt;In the previous section, we observed that knowing one variable canmean that communicating another variable requires less information.&lt;/p&gt;&lt;p&gt;One nice way to think about this is to imagine amounts of informationas bars. These bars overlap if there’s shared information between them:some of the information in &lt;spanclass=”math inline”&gt;<em>X</em>&lt;/span&gt; and &lt;spanclass=”math inline”&gt;<em>Y</em>&lt;/span&gt; is shared between them, so &lt;spanclass=”math inline”&gt;<em>H</em>(<em>X</em>)&lt;/span&gt; and &lt;spanclass=”math inline”&gt;<em>H</em>(<em>Y</em>)&lt;/span&gt; are overlapping bars.And since &lt;spanclass=”math inline”&gt;<em>H</em>(<em>X</em>, <em>Y</em>)&lt;/span&gt; is theinformation in both, it’s the union of the bars &lt;spanclass=”math inline”&gt;<em>H</em>(<em>X</em>)&lt;/span&gt; and &lt;spanclass=”math inline”&gt;<em>H</em>(<em>Y</em>)&lt;/span&gt;.&lt;/p&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/Hxy-info-1.png”alt=”Multi-variate bar 1” /&gt;&lt;figcaption aria-hidden="true"&gt;Multi-variate bar 1&lt;/figcaption&gt;</figure>&lt;p&gt;We rank the information needed to communicate these 3 kinds of thingsin descending order:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Both <span class="math inline"><em>X</em></span> and &lt;spanclass=”math inline”&gt;<em>Y</em>&lt;/span&gt;: joint entropy &lt;spanclass=”math inline”&gt;<em>H</em>(<em>X</em>, <em>Y</em>)&lt;/span&gt;&lt;/li&gt;&lt;li&gt;<span class="math inline"><em>X</em></span> alone: marginal entropy<span class="math inline"><em>H</em>(<em>X</em>)</span>&lt;/li&gt;&lt;li&gt;<span class="math inline"><em>X</em></span> when &lt;spanclass=”math inline”&gt;<em>Y</em>&lt;/span&gt; is known: conditional entropy<span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>)</span>&lt;/li&gt;&lt;/ul&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/Hxy-overview.png”alt=”Ranking information contained” /&gt;&lt;figcaption aria-hidden="true"&gt;Ranking informationcontained&lt;/figcaption&gt;</figure>&lt;p&gt;In the bar perspective, &lt;spanclass=”math inline”&gt;<em>H</em>(<em>X</em>|<em>Y</em>)&lt;/span&gt; is theinformation we need to send to communicate &lt;spanclass=”math inline”&gt;<em>X</em>&lt;/span&gt; to someone who already knows &lt;spanclass=”math inline”&gt;<em>Y</em>&lt;/span&gt; - it is the information in &lt;spanclass=”math inline”&gt;<em>X</em>&lt;/span&gt; which isn’t also in &lt;spanclass=”math inline”&gt;<em>Y</em>&lt;/span&gt;. Visually, that means &lt;spanclass=”math inline”&gt;<em>H</em>(<em>X</em>|<em>Y</em>)&lt;/span&gt; is the partof <span class="math inline"><em>H</em>(<em>X</em>)</span> bar whichdoesn’t overlap with &lt;spanclass=”math inline”&gt;<em>H</em>(<em>Y</em>)&lt;/span&gt;.&lt;/p&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/Hxy-info-4.png”alt=”Multi-variate bar 2” /&gt;&lt;figcaption aria-hidden="true"&gt;Multi-variate bar 2&lt;/figcaption&gt;</figure>&lt;p&gt;From this, we get another identity: the information in &lt;spanclass=”math inline”&gt;<em>X</em>&lt;/span&gt; and &lt;spanclass=”math inline”&gt;<em>Y</em>&lt;/span&gt; is the information in &lt;spanclass=”math inline”&gt;<em>Y</em>&lt;/span&gt; plus the information in &lt;spanclass=”math inline”&gt;<em>X</em>&lt;/span&gt; which is not in &lt;spanclass=”math inline”&gt;<em>Y</em>&lt;/span&gt;. (sounds like set, doesn’tit?)&lt;/p&gt;&lt;p&gt;&lt;spanclass=”math display”&gt;<em>H</em>(<em>X</em>, <em>Y</em>) = <em>H</em>(<em>Y</em>) + <em>H</em>(<em>X</em>|<em>Y</em>)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;To wrap up, we have&lt;/p&gt;&lt;ul&gt;&lt;li&gt;information in each variable: &lt;spanclass=”math inline”&gt;<em>H</em>(<em>X</em>)&lt;/span&gt; and &lt;spanclass=”math inline”&gt;<em>H</em>(<em>Y</em>)&lt;/span&gt;&lt;/li&gt;&lt;li&gt;union of the information in both: &lt;spanclass=”math inline”&gt;<em>H</em>(<em>X</em>, <em>Y</em>)&lt;/span&gt;&lt;/li&gt;&lt;li&gt;information in one but not the other: &lt;spanclass=”math inline”&gt;<em>H</em>(<em>X</em>|<em>Y</em>)&lt;/span&gt; and &lt;spanclass=”math inline”&gt;<em>H</em>(<em>Y</em>|<em>X</em>)&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;We can further define <strong>mutual information</strong>:information both in <span class="math inline"><em>X</em></span> and<span class="math inline"><em>Y</em></span>, or in set terms, theintersection of information:&lt;/p&gt;&lt;p&gt;&lt;spanclass=”math display”&gt;<em>I</em>(<em>X</em>, <em>Y</em>) = <em>H</em>(<em>X</em>) + <em>H</em>(<em>Y</em>) − <em>H</em>(<em>X</em>, <em>Y</em>)&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;If you expand the definition of mutual information out, you get:&lt;/p&gt;&lt;p&gt;<span class="math display">\(I(X,Y) = \sum_{x,y} p(x,y) \log_2\left(\frac{p(x,y)}{p(x)p(y)} \right)\)</span>&lt;/p&gt;&lt;p&gt;That looks suspiciously like KL divergence!&lt;/p&gt;&lt;p&gt;Well, it is KL divergence. It’s the KL divergence of &lt;spanclass=”math inline”&gt;<em>P</em>(<em>X</em>, <em>Y</em>)&lt;/span&gt; and itsnaive approximation &lt;spanclass=”math inline”&gt;<em>P</em>(<em>X</em>)<em>P</em>(<em>Y</em>)&lt;/span&gt;.That is, it’s the number of bits you save representing &lt;spanclass=”math inline”&gt;<em>X</em>&lt;/span&gt; and &lt;spanclass=”math inline”&gt;<em>Y</em>&lt;/span&gt; if you understand the relationshipbetween them instead of assuming they’re independent.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;and the <strong>variation of information</strong>. The variation ofinformation is the information which isn’t shared between the variables.It gives a metric of distance between different variables. The variationof information between two variables is zero if knowing the value of onetells you the value of the other and increases as they become moreindependent.&lt;/p&gt;&lt;p&gt;&lt;spanclass=”math display”&gt;<em>V</em>(<em>X</em>, <em>Y</em>) = <em>H</em>(<em>X</em>, <em>Y</em>) − <em>I</em>(<em>X</em>, <em>Y</em>)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;How does this relate to KL divergence, which also gave us a notion ofdistance? Well, KL divergence gives us a distance between twodistributions <strong>over the same variable or set ofvariables</strong>. In contrast, variation of information gives usdistance between <strong>two jointly distributed variables</strong>. KLdivergence is <strong>between distributions</strong>, variation ofinformation <strong>within a distribution</strong>.&lt;/p&gt;&lt;p&gt;In summary, we put them all in a single diagram:&lt;/p&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/Hxy-info.png”alt=”Multi-variate bar 3” /&gt;&lt;figcaption aria-hidden="true"&gt;Multi-variate bar 3&lt;/figcaption&gt;</figure>&lt;h2 id="fractional-bits"&gt;Fractional Bits&lt;/h2&gt;&lt;p&gt;A careful reader may have noticed that in &lt;ahref=”#conditional-entropy”&gt;previous calculations&lt;/a&gt;, we had fractionallength of message. Isn’t that weird? How should we interpret such amessage? How is it done in real life?&lt;/p&gt;&lt;p&gt;The answer is: you can think of them as expected length of a message.If half the time one sends a single bit, and half the time one sends twobits, on average one sends one and a half bits. There’s nothing strangeabout averages being fractional.&lt;/p&gt;&lt;p&gt;That’s a quick but vague answer. Let’s look at an example: consider aprobability distribution where one event &lt;spanclass=”math inline”&gt;<em>a</em>&lt;/span&gt; happens 71% of the time andanother event <span class="math inline"><em>b</em></span> occurs 29% ofthe time.&lt;/p&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/halfbit-ab.png”alt=”Fractional bit single” /&gt;&lt;figcaption aria-hidden="true"&gt;Fractional bit single&lt;/figcaption&gt;</figure>&lt;p&gt;The optimal code would use 0.5 bits to represent &lt;spanclass=”math inline”&gt;<em>a</em>&lt;/span&gt;, and 1.7 bits to represent &lt;spanclass=”math inline”&gt;<em>b</em>&lt;/span&gt;. Well, if we want to send a singleone of these codewords, it simply isn’t possible. We’re forced to roundto a whole number of bits, and send on average 1 bit.&lt;/p&gt;&lt;p&gt;… But if we’re sending multiple messages at once, it turns out thatwe can do better. Let’s consider communicating two events from thisdistribution. If we send them independently, using the code weestablished for a single event, we’d need to send two bits. Can we dobetter?&lt;/p&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/halfbit-ab2.png”alt=”Fractional bit double” /&gt;&lt;figcaption aria-hidden="true"&gt;Fractional bit double&lt;/figcaption&gt;</figure>&lt;p&gt;Half the time, we need to communicate &lt;spanclass=”math inline”&gt;<em>a</em><em>a</em>&lt;/span&gt;, 21% of the time we needto send <span class="math inline"><em>a</em><em>b</em></span> or &lt;spanclass=”math inline”&gt;<em>b</em><em>a</em>&lt;/span&gt;, and 8% of the time weneed to communicate &lt;spanclass=”math inline”&gt;<em>b</em><em>b</em>&lt;/span&gt;. Again, the ideal codeinvolves fractional numbers of bits.&lt;/p&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/halfbit-ab-idealcode.png”alt=”Fractional bit double code length” /&gt;&lt;figcaption aria-hidden="true"&gt;Fractional bit double codelength&lt;/figcaption&gt;</figure>&lt;p&gt;If we round the codeword lengths, we’ll get something like this:&lt;/p&gt;<figure>&lt;imgsrc=”https://colah.github.io/posts/2015-09-Visual-Information/img/halfbit-ab-code.png”alt=”Fractional bit double code length rounded” /&gt;&lt;figcaption aria-hidden="true"&gt;Fractional bit double code lengthrounded&lt;/figcaption&gt;</figure>&lt;p&gt;This codes give us an average message length of &lt;spanclass=”math inline”&gt;1.8&lt;/span&gt; bits. That’s less than the &lt;spanclass=”math inline”&gt;2&lt;/span&gt; bits when we send themindependently. Another way of thinking of this is that we’re sending<span class="math inline">1.8/2 = 0.9</span> bits on average for eachevent. If we were to send more events at once, it would become smallerstill. As <span class="math inline"><em>n</em></span> tends to infinity,the overhead due to rounding our code would vanish, and the number ofbits per codeword would approach the entropy.&lt;/p&gt;&lt;p&gt;Further, notice that the ideal codeword length for a was 0.5 bits,and the ideal codeword length for aa was 1 bit. Ideal codeword lengthsadd, even when they’re fractional! So, if we communicate a lot of eventsat once, the lengths will add.&lt;/p&gt;&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Entropy is optimal length ..&lt;/li&gt;&lt;li&gt;KL divergence ..&lt;/li&gt;&lt;li&gt;Entropy over multiple variables can be interpreted as sets ofinformation&lt;/li&gt;&lt;/ul&gt;</p> </body></html>