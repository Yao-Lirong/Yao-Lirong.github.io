<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <p>This is a detailed reading of Google’s paper &lt;ahref="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/45530.pdf"&gt;DeepNeural Networks for YouTube Recommendations&lt;/a&gt;</p> <p><span id="more"></span>&lt;h2 id="candidate-generation"&gt;Candidate Generation&lt;/h2&gt;&lt;h3 id="problem-setup"&gt;Problem Setup&lt;/h3&gt;&lt;p&gt;We pose recommendation as an extreme multi-class classificationproblem where we <strong>predict which video will be watchednext</strong>. Specifically, we classify a specific video watch &lt;spanclass=”math inline”&gt;<em>w</em><sub><em>t</em></sub>&lt;/span&gt; at time &lt;spanclass=”math inline”&gt;<em>t</em>&lt;/span&gt; among millions of videos &lt;spanclass=”math inline”&gt;<em>i</em>&lt;/span&gt; (classes) from a video corpus<span class="math inline"><em>V</em></span> based on a user &lt;spanclass=”math inline”&gt;<em>U</em>&lt;/span&gt; and context &lt;spanclass=”math inline”&gt;<em>C</em>&lt;/span&gt;. And <span class="math inline">$u\in \R^d$</span> represents a high-dimensional “embedding” of theuser-context pair and the <span class="math inline">$v_j \in\R^d$</span> represent embeddings of each candidate video. &lt;spanclass=”math display”&gt;<em>P</em>(<em>w</em><sub><em>t</em></sub> = <em>i</em> ∣ <em>U</em>, <em>C</em>) = <code>Softmax</code>(<em>V</em>, <em>u</em>)<sub><em>i</em></sub>&lt;/span&gt;&lt;/p&gt;&lt;h3 id="input"&gt;Input&lt;/h3&gt;&lt;p&gt;what we didn’t use: explicit feedback (thumbs up/down, in-productsurveys) because there’s too few of them in the tail of videos.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;<strong>embedded video watches</strong>:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;<strong>representation of each video</strong>: in myunderstanding, YouTube didn’t extract information from their videos, andfed the extracted info into the embedder. Instead, they directly fed thevideo ids into the embedder. To my understanding, “Inspired bycontinuous bag of words language models” means they fed the video idsinto the embedder, just like NLP feeds BoW representation into embedder.It doesn’t mean YouTube decomposes a video into word count like BoW.&lt;/p&gt;&lt;p&gt;I reached this conclusion from the last sentence of 4.1 FeatureRepresentation - Embedding Categorical Features, where<code>1000000*32 / (2048*2048) = 7</code>&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The overwhelming majority of model parameters are in thesehigh-cardinality embedding spaces - for example, one million IDsembedded in a 32 dimensional space have 7 times more parameters thanfully connected layers 2048 units wide.&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;<strong>representation of watch history</strong>: watch historyis a variable-length list of videos. YouTube used average-pooling totransform them into a fixed-length vector.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;<strong>why order-independent pooling?</strong>&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;<strong>embedded search tokens</strong>: each query is tokenizedinto unigrams and bigrams. each token is embedded. All these embeddedtokens from all queries are then pooled and fed into the model as asummarized dense search history.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;<strong>geographic embeddings</strong>: The user’s geographicregion and device are embedded and concatenated.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;<strong>Simple binary and continuous features</strong>: such asthe user’s gender, logged-in state and age are input directly into thenetwork as real values normalized to [0, 1].&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;<strong>example (sample) age</strong>: ML model often has biastowards past samples because there’s more data about them. It’s commonto promote video freshness during re-rank phase, but YouTube also try toreduce this bias as early as in candidate generation phase. We definethe example age to be the time between training and obtaining thissample. e.g. <code>t</code> days earlier, after having watched video<code>v</code>, user searched word <code>w</code> and clicked on anothervideo <code>y</code>. We use this sample in training, so its sample ageis <code>t</code>. By introducing this feature, our model no longerreflects the average watch likelihood in the training window of severalweeks, but the likelihood at a specific time step. At serving time, thisfeature is set to zero (or slightly negative) to reflect that the modelis making predictions at the very end of the training window.&lt;/p&gt;&lt;p&gt;总结某&lt;ahref=”https://zhuanlan.zhihu.com/p/52504407”&gt;知乎讨论下的内容&lt;/a&gt;:example age 和消除第一种 ad position bias 做法类似&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;纯feed应用中前置内容点击率被高估：新闻客户端，position靠前的是虚高的，这部分叫positionbias，输入给模型的时候也要输入它们的位置，在线上预估时置0&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;搜索偏向应用中前置内容点击率被低估：手百，手淘，美团等，都会在首页默认展示feed，但很多目的明确的用户压根不会用这些推荐功能，导致这部分展示的内容点击率是被低估了。实际操作中大家可能只针对有feed互动的用户进行采样，抛弃了完全过路型用户的行为，也算是修正bias了&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="data-gathering-details"&gt;Data Gathering Details&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;<strong>Class Balance</strong>: generate a fixed number oftraining examples per user, effectively weighting our users equally inthe loss function&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;<strong>Permutation-Invariant Pooling</strong>: in pooling,YouTube chose average pooling among sum, max, etc, because averageperformed the best. The important thing is, they decided to abandonsequence information whatsoever. Their explanation is below and I don’tquite buy it because they’re definitely better way to solve this problemthan discarding the info altogether. In addition, they did publish &lt;ahref=”https://research.google/pubs/latent-cross-making-use-of-context-in-recurrent-recommender-systems/”&gt;anotherpaper on sequence-based recommendation system&lt;/a&gt; later. I think at thispaper’s publishing time, they either didn’t want to publicize it or havenot tested that in detail.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Consider the user has just issued a search query for “taylor swift”.Since our problem is posed as predicting the next watched video, aclassifier given this information will predict that the most likelyvideos to be watched are those which appear on the corresponding searchresults page for “taylor swift”. Unsurprisingly, reproducing the user’slast search page as homepage recommendations performs very poorly. Bydiscarding sequence information and representing search queries with anunordered bag of tokens, the classifier is no longer directly aware ofthe origin of the label.&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;<strong>Next-Watch Heldout</strong>: at the time, manycollaborative filtering systems implicitly choose the labels and contextby holding out a random item and predicting it from other items in theuser’s history. They decided to always hold out and predict user’s nextwatch and achieved much better results. This is now already thestandard. In fact it appeared in my college class CS4780 byKillian.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="training"&gt;Training:&lt;/h3&gt;&lt;p&gt;In these experiments, a vocabulary of 1M videos and 1M search tokenswere embedded with 256 floats each in a maximum bag size of 50 recentwatches and 50 recent searches. The softmax layer outputs a multinomialdistribution over the same 1M video classes with a dimension of 256(which can be thought of as a separate output video embedding).&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;<strong>negative sampling</strong>: for the same user, inaddition to his watched videos, we also sample some unwatched videos togeneralize the model.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;<strong>Importance Weighting</strong>: we do not take softmaxover all the 1M videos. Instead, we sample ~5000 of them, compute theirprobability, re-weight them based on importance (<strong>watch time,click rate?</strong>) and only compute loss over these samples.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;<strong>loss</strong>: this is a multi-class classificationproblem, so we use cross-entropy loss naturally&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="inference-serving"&gt;Inference / Serving:&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;<strong>kNN</strong>: In serving, we need an algorithm sublinearto number of classes (videos to recommend). Say the last layer of thenetwork has hidden dimension <span class="math inline"><em>d</em></span>and we have <span class="math inline"><em>N</em></span> videos topredict. Decoding hidden dimension back into per-video logits and take asoftmax takes &lt;spanclass=”math inline”&gt;<em>O</em>(<em>d</em><em>N</em>)&lt;/span&gt;. Sortingtakes &lt;spanclass=”math inline”&gt;<em>O</em>(<em>N</em>log <em>N</em>)&lt;/span&gt;. Thetotal time is &lt;spanclass=”math inline”&gt;<em>O</em>(<em>d</em><em>N</em> + <em>N</em>log <em>N</em>)&lt;/span&gt;.On the other hand, naive kNN takes &lt;spanclass=”math inline”&gt;<em>O</em>(<em>d</em><em>N</em>)&lt;/span&gt; time intotal and some heuristic version like Ball tree can take &lt;spanclass=”math inline”&gt;<em>O</em>(<em>d</em>log <em>N</em>)&lt;/span&gt;​​.&lt;/p&gt;&lt;p&gt;distance is based on dot product&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;<strong>how do we get video embedding? (where isdecoder?)</strong>&lt;/p&gt;<figure>&lt;img src=”/images/youtube-candidate-generation-architecture.png”alt=”youtube-candidate-generation-architecture” /&gt;&lt;figcaptionaria-hidden=”true”&gt;youtube-candidate-generation-architecture&lt;/figcaption&gt;</figure>&lt;p&gt;All classification models have to include a decoder (FC layer) at theend of the network but before the softmax layer to decode the hiddenvector back to per-video logits in video ID space to make prediction. Ifwe have 1M videos and hidden vector is of dimension 256, the decoder isa matrix of size [256, 1M]. However, the graph presented in the paper isvery confusing because the authors omit drawing the decoder and made itan implicit part of the softmax layer.&lt;/p&gt;&lt;p&gt;Anyway, we know we do have that decoder, so it’s natural to use thevectors in the decoder as our video embedding. The i-th video’sembedding is simply <code>decoder[:, i]</code>.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;<strong>weight sharing / weight tying</strong>: this is a conceptI encountered in nanoGPT and has become clear here. At the beginning ofthe network, we have a video encoder from video ID space to hiddenspace; at the end of the network, we have a video decoder from hiddenspace back to video ID space. It is possible to share weights (use thesame weights) in encoder and decoder to save space (recall this partcosts the most parameter). This is just mentioned by people in &lt;ahref=”https://zhuanlan.zhihu.com/p/52504407”&gt;comment section&lt;/a&gt; and isnot implemented by Google.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id="ranking"&gt;Ranking&lt;/h2&gt;&lt;h3 id="problem-setup-1"&gt;Problem Setup&lt;/h3&gt;&lt;p&gt;We pose ranking as <strong>predicting the expected watch time of avideo</strong>. Ranking by click-through rate often promotes deceptivevideos that the user does not complete (“clickbait”) whereas watch timebetter captures engagement&lt;/p&gt;&lt;h3 id="input-feature-engineering"&gt;Input (Feature Engineering)&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;user’s previous interaction with the item itself and other similaritems: e.g. user’s past history with the channel that uploaded the videobeing scored (how many videos has the user watched from this channel?When was the last time the user watched a video on this topic?)&lt;/li&gt;&lt;li&gt;propagate information from candidate generation into ranking in theform of features: e.g. which sources nominated this video candidate?What scores did they assign?&lt;/li&gt;&lt;li&gt;frequency of past video impressions: If a user was recentlyrecommended a video but did not watch it then the model will naturallydemote this impression on the next page load.&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="input-details"&gt;Input Details&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;embedding space should increase approximately proportional to the<strong>logarithm</strong> of the number of unique values of dataspace&lt;/li&gt;&lt;li&gt;very large space (video id &amp; query token) is <strong>truncatedby click-through-rate</strong>. So we only recommend videos above acertain CTR. Note these filtered out videos can still be searchedout.&lt;/li&gt;&lt;li&gt;Out-of-vocabulary values (new / truncated videos) are mapped to the<strong>zero embedding</strong>.&lt;/li&gt;&lt;li&gt;Continuous features are always <strong>normalized</strong> to [0,1)&lt;/li&gt;&lt;li&gt;In addition to the raw normalized feature &lt;spanclass=”math inline”&gt;<em>x</em>&lt;/span&gt;, we also input &lt;spanclass=”math inline”&gt;$\sqrt x$&lt;/span&gt; and &lt;spanclass=”math inline”&gt;<em>x</em><sup>2</sup>&lt;/span&gt;​, giving the networkmore expressive power by allowing it to easily form <strong>super- andsub-linear</strong> functions of the feature. Feeding powers ofcontinuous features was found to improve offline accuracy.&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="training-1"&gt;Training&lt;/h3&gt;&lt;p&gt;We use Logistic Regression to predict expected watch time (EWT) of avideo, but LR only predicts 0 or 1. How can we use it to predict EWT? Weuse weighted logistic regression, where the positive (clicked)impressions are weighted by the observed watch time on the video.Negative (unclicked) impressions all receive unit weight.&lt;/p&gt;&lt;p&gt;In training, we use the weighted cross entropy loss: &lt;spanclass=”math display”&gt;<code>WeightedCrossEntropy</code> = −∑<sub><em>i</em></sub>[<em>T</em><sub><em>i</em></sub><em>y</em><sub><em>i</em></sub>log <em>p</em><sub><em>i</em></sub> + (1 − <em>y</em><sub><em>i</em></sub>)log (1 − <em>p</em><sub><em>i</em></sub>)]&lt;/span&gt;### Serving&lt;/p&gt;&lt;p&gt;In serving, we directly output &lt;spanclass=”math inline”&gt;<em>e</em><sup><em>θ</em><em>x</em></sup>&lt;/span&gt; asthe predicted watch time. Why is this the watch time? Recall in LogisticRegression, we have a binary classification problem, so we can define&lt;spanclass=”math inline”&gt;<em>P</em>(<em>Y</em><sub><em>i</em></sub> = 1|<em>X</em><sub><em>i</em></sub>) = <em>p</em>, <em>P</em>(<em>Y</em><sub><em>i</em></sub> = 0|<em>X</em><sub><em>i</em></sub>) = 1 − <em>p</em>&lt;/span&gt;and <span class="math display">\(p = \frac{1}{1 + e^{-\theta^T x}}\)</span> In statistics, we define odds as: &lt;spanclass=”math display”&gt;\(\texttt{odds} = \frac{p}{1-p} = \frac{1}{e^{-\theta^Tx}} = e^{\theta^Tx}\)&lt;/span&gt; If we take a log at both sides, we have the log odds, or<strong>logits</strong> <span class="math display">\(\ln(\texttt{odds}) = \ln(\frac{p}{1-p}) = \theta^Tx\)</span> Now let’s look at the our weighted logistic regressionproblem: Positive impressions are weighted by watch time &lt;spanclass=”math inline”&gt;<em>T</em><sub><em>i</em></sub>&lt;/span&gt;. Negativeimpressions receive unit weight. We have a total &lt;spanclass=”math inline”&gt;<em>N</em>&lt;/span&gt; videos, and &lt;spanclass=”math inline”&gt;<em>k</em>&lt;/span&gt; of them are positive (clicked). Wehave <span class="math inline"><em>k</em> = <em>p</em><em>N</em></span>and the expected watch time of all videos is &lt;spanclass=”math inline”&gt;$\mathbb E[T] = \frac{\sum_i^k T_i}{N}$&lt;/span&gt;. Nowlook at our weighted odds: <span class="math display">\(\begin{align}\texttt{wghted odds} &amp;amp;= \frac{\text{weighted posprob}}{\text{weighted neg prob}}\\&amp;amp;= \frac{\sum_i^k T_i}{N-k} = \frac{\sum_i^k T_i}{N-pN} =\frac{\sum_i^k T_i}{N(1-p)} = \frac{\sum_i^k T_i}{N}\frac{1}{1-p}\\&amp;amp; = \mathbb E[T](1+p) \approx \mathbb E[T] \hspace{20px}\text{($p$is small)}\end{align}\)</span> Therefore, at serving time, we can directly output &lt;spanclass=”math inline”&gt;<em>e</em><sup><em>θ</em><em>x</em></sup>&lt;/span&gt;because it is the expected watch time.&lt;/p&gt;&lt;h3 id="evaluation-metric"&gt;Evaluation Metric&lt;/h3&gt;&lt;p&gt;Since we’re essentially predicting a video’s watch time, we“wrongly-predicted video’s watch time” as our evaluation metric. In thepaper, author called it “weighted, per-user loss”. Specifically, foreach user, we feed the model both positive (clicked) and negative(unclicked) impressions shown to him on a single page. We first predicttheir respective watch time with our model. “mispredicted watch time” isthe positive video’s watch time when the negative impression receives alonger predicted watch time than the positive impression. This user’sloss is total mispredicted watch time / total watch time of ground-truth(positive) impressions.&lt;/p&gt;&lt;h2 id="takeaway"&gt;Takeaway&lt;/h2&gt;&lt;p&gt;example age&lt;/p&gt;&lt;p&gt;expected watch time&lt;/p&gt;&lt;p&gt;KNN - quick serving&lt;/p&gt;&lt;p&gt;feature engineering&lt;/p&gt;&lt;p&gt;what is <strong>surrogate problem</strong>?&lt;/p&gt;&lt;p&gt;https://www.youtube.com/watch?v=WK_Nr4tUtl8&lt;/p&gt;&lt;h2 id="comment"&gt;Comment&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;RNN这个方法在17年已经由AlexBeutel做上线了，其实在16年初就想做，只是效果还没有完全出来，后来Alex发现了原先做法的一些弱点，很快改进之后就上线了，作为重要的candidatesgeneration来源；排序目标只写了EWT，一是Google的技术保密要求，毕竟还是要做到HR-safe的，论文只能点到即止，二是相对有效并且能够比分开预测ctr和staytime能节省servinglatenc&lt;/p&gt;&lt;p&gt;– &lt;ahref=”https://www.zhihu.com/people/dcb32aa26dd3a456bd79d2c2cdffa433”&gt;严林&lt;/a&gt;under &lt;ahref=”https://zhuanlan.zhihu.com/p/52169807”&gt;重读Youtube深度学习推荐系统论文，字字珠玑，惊为神文&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;</p> </body></html>