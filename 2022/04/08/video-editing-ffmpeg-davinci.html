<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <p>主要记录视频的一些相关知识以及 FFmpeg 和 DaVinci 的常见用法</p> <p><span id="more"></span>&lt;h2 id="FFmpeg-Video"&gt;<a href="#FFmpeg-Video" class="headerlink" title="FFmpeg - Video"></a>FFmpeg - Video&lt;/h2&gt;&lt;h3 id="File-Format-Conversion"&gt;<a href="#File-Format-Conversion" class="headerlink" title="File Format Conversion"></a>File Format Conversion&lt;/h3&gt;&lt;p&gt;For most simple tasks, you can just do &lt;/p&gt;<figure class="highlight bash">&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;<span class="line">1</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;<span class="line">ffmpeg -i input.avi output.mp4</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</figure>&lt;p&gt;and <code>ffmpeg</code> will figure out how to perform that conversion. &lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;<a href="https://www.cnblogs.com/zmj97/p/10180702.html" rel="external nofollow noopener" target="_blank">FFmpeg 合并文件</a>:&lt;/p&gt;<figure class="highlight bash">&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;<span class="line">1</span><br><span class="line">2</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;<span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> *.flv; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">"file '<span class="variable">$f</span>'"</span> &gt;&gt; mylist.txt; <span class="keyword">done</span></span><br><span class="line">ffmpeg -f concat -i mylist.txt -c copy output.flv</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</figure>&lt;p&gt;更详细的官方文档在<a href="https://trac.ffmpeg.org/wiki/Concatenate" rel="external nofollow noopener" target="_blank">这里</a>。具体地来看，我们这里用的是 concat demuxer, 这项协议支持不同的容器格式，甚至是本身不支持 concat 操作的容器格式的合并 &lt;/p&gt;<figure class="highlight bash">&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;<span class="line">1</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;<span class="line">ffmpeg -i <span class="string">"concat:input1|input2"</span> -codec copy output.mkv</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</figure>&lt;p&gt;对于 ts 之类本身支持 file-level concat 的文件格式，可以直接使用如上的 concat protocol (参考 <a href="https://stackoverflow.com/a/11175851/" rel="external nofollow noopener" target="_blank">stackoverflow 答案1</a>, <a href="https://stackoverflow.com/questions/14829819/how-to-concatenate-flv-file-into-one/14839514#14839514" rel="external nofollow noopener" target="_blank">答案2</a>)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;<a href="https://askubuntu.com/a/716457" rel="external nofollow noopener" target="_blank">FFmpeg 转换格式</a>:&lt;/p&gt;<figure class="highlight bash">&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;<span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;<span class="line"><span class="comment"># stream copy all streams</span></span><br><span class="line">ffmpeg -i input -map 0 -c copy output.mp4 </span><br><span class="line"></span><br><span class="line"><span class="comment"># re-encode the video to H.264 and stream copy the audio</span></span><br><span class="line">ffmpeg -i input.ts -c:v libx264 -c:a copy output.mp4 </span><br>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</figure>&lt;/li&gt;&lt;li&gt;&lt;p&gt;<a href="https://stackoverflow.com/q/39861885/" rel="external nofollow noopener" target="_blank">FFmpeg 批处理转换格式</a>:&lt;/p&gt;<figure class="highlight bash">&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;<span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;<span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> *.avi;</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> ffmpeg -i <span class="string">"<span class="variable">$i</span>"</span> -c:v libx265 -c:a copy X265_<span class="string">"<span class="variable">$i</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</figure>&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="Editing-Clipping-Encoding"&gt;<a href="#Editing-Clipping-Encoding" class="headerlink" title="Editing, Clipping, Encoding"></a>Editing, Clipping, Encoding&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;<a href="https://stackoverflow.com/a/27413824/12006199" rel="external nofollow noopener" target="_blank">Extract Audio from Video</a>: where <code>-vn</code> disables video processing &lt;/p&gt;<figure class="highlight bash">&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;<span class="line">1</span><br><span class="line">2</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;<span class="line">ffmpeg -i input.mp4 -vn -acodec copy output-audio.aac <span class="comment"># extract aac</span></span><br><span class="line">ffmpeg -i input.mp4 -vn -acodec copy output-audio.opus <span class="comment"># extract opus</span></span><br>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</figure>&lt;/li&gt;&lt;li&gt;&lt;p&gt;<a href="https://www.cnblogs.com/renhui/p/9209664.html" rel="external nofollow noopener" target="_blank">FFmpeg查看媒体信息</a>: 使用 <code>ffprobe</code>&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;<a href="https://superuser.com/a/927507/" rel="external nofollow noopener" target="_blank">Extract Subtitles</a>: On <a href="https://stackoverflow.com/a/72415890/" rel="external nofollow noopener" target="_blank">hdmv_pgs_subtitle</a>, where we need sup format. &lt;/p&gt;<figure class="highlight bash">&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;<span class="line">1</span><br><span class="line">2</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;<span class="line">ffmpeg -i video.mkv -map 0:s:0 -c copy subs.sup</span><br><span class="line">ffmpeg -i Movie.mkv -map 0:s:0 -c copy subs.srt</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</figure>&lt;/li&gt;&lt;li&gt;&lt;p&gt;<a href="https://trac.ffmpeg.org/wiki/Encode/H.265" rel="external nofollow noopener" target="_blank">FFmpeg H.265 Reencode</a>: if you use all the settings as default, just do:&lt;/p&gt;<figure class="highlight bash">&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;<span class="line">1</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;<span class="line">ffmpeg -i input -c:v libx265 -c:a copy output.mp4</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</figure>&lt;/li&gt;&lt;li&gt;&lt;p&gt;<a href="https://superuser.com/questions/138331/using-ffmpeg-to-cut-up-video" rel="external nofollow noopener" target="_blank">Clip Video</a>: you should primarily read <a href="https://trac.ffmpeg.org/wiki/Seeking" rel="external nofollow noopener" target="_blank">this wiki page</a>, which introduces you to seeking in ffmpeg. In short, you should use <code>-ss</code> before <code>-i</code> in most cases. &lt;/p&gt;<figure class="highlight bash">&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;<span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;<span class="line"><span class="comment"># -ss used before -i: parse input using keyframes, which is very fast</span></span><br><span class="line"><span class="comment"># gives exactly the same output</span></span><br><span class="line">ffmpeg -ss 00:40:30 -i 20170301.mp4 -t 310 -c copy 1.mp4 </span><br><span class="line">ffmpeg -ss 00:40:30 -to 00:45:40 -i 20170301.mp4 -c copy 2.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># -ss used after -i: decodes but discards input until the timestamps reach position. </span></span><br><span class="line"><span class="comment"># which is done very slowly, frame by frame</span></span><br><span class="line">ffmpeg -i 20170301.mp4 -ss 00:40:30 -to 00:45:40 -c copy 3.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># Doesn't work, will output something at most 45:40 long</span></span><br><span class="line">ffmpeg -ss 00:40:30 -i 20170301.mp4 -to 00:45:40 -c copy 4.mp4</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</figure>&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="Broken-File-Fix"&gt;<a href="#Broken-File-Fix" class="headerlink" title="Broken File Fix"></a>Broken File Fix&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;<a href="https://stackoverflow.com/a/52847587/12006199" rel="external nofollow noopener" target="_blank">Fill Missing Time Stamps with Empty Audio</a>: &lt;/p&gt;<figure class="highlight bash">&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;<span class="line">1</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;<span class="line">ffmpeg -i input -af aresample=async=1 output.wav</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</figure>&lt;/li&gt;&lt;li&gt;&lt;p&gt;<a href="https://www.reddit.com/r/ffmpeg/comments/nf960l/fill_missing_video_frames/gyseli3/" rel="external nofollow noopener" target="_blank">Fill Missing Frames (Change Variable Frame to Constant Frame)</a>:&lt;/p&gt;<figure class="highlight bash">&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;<span class="line">1</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;<span class="line">ffmpeg -i input -vf <span class="string">"fps=30"</span> output.mp4</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</figure>&lt;/li&gt;&lt;li&gt;&lt;p&gt;<a href="https://stackoverflow.com/a/12375018/" rel="external nofollow noopener" target="_blank">Create a Silent Audio Track</a> &lt;/p&gt;<figure class="highlight bash">&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;<span class="line">1</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;<span class="line">ffmpeg -f lavfi -i anullsrc=channel_layout=stereo:sample_rate=44100 -i video.mov -c:v copy -c:a aac -shortest output.mov</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</figure>&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="Others"&gt;<a href="#Others" class="headerlink" title="Others"></a>Others&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;ffmpeg <a href="https://stackoverflow.com/a/53308111/12006199" rel="external nofollow noopener" target="_blank">download m3u8 file</a> with <a href="https://stackoverflow.com/a/59657204/12006199" rel="external nofollow noopener" target="_blank">custome user-agent</a>: If flag <code>-user_agent</code> is not working, you can use <code>-headers</code>, referenced <a href="https://stackoverflow.com/a/41709762/12006199" rel="external nofollow noopener" target="_blank">here</a> &lt;/p&gt;<figure class="highlight bash">&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;<span class="line">1</span><br><span class="line">2</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;<span class="line">ffmpeg -user_agent <span class="string">"SNH48 ENGINE"</span> -i <span class="string">"https://xxx.m3u8"</span> -codec copy file.mp4</span><br><span class="line">ffmpeg -headers <span class="string">'User-Agent: Mozilla'</span> -i <span class="string">"https://xxx.m3u8"</span> -codec copy file.mp4</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</figure>&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;<a href="https://superuser.com/questions/1041816/combine-one-image-one-audio-file-to-make-one-video-using-ffmpeg" rel="external nofollow noopener" target="_blank">https://superuser.com/questions/1041816/combine-one-image-one-audio-file-to-make-one-video-using-ffmpeg</a>&lt;/p&gt;&lt;h2 id="FFmpeg-Audio"&gt;<a href="#FFmpeg-Audio" class="headerlink" title="FFmpeg - Audio"></a>FFmpeg - Audio&lt;/h2&gt;&lt;p&gt;！！！整理！！！&lt;/p&gt;&lt;p&gt;<a href="https://stackoverflow.com/questions/46508055/using-ffmpeg-to-cut-audio-from-to-position" rel="external nofollow noopener" target="_blank">https://stackoverflow.com/questions/46508055/using-ffmpeg-to-cut-audio-from-to-position</a>&lt;/p&gt;&lt;p&gt;<a href="https://stackoverflow.com/questions/71158575/output-file-is-empty-nothing-was-encoded-check-ss-t-frames-parameters-i" rel="external nofollow noopener" target="_blank">https://stackoverflow.com/questions/71158575/output-file-is-empty-nothing-was-encoded-check-ss-t-frames-parameters-i</a>&lt;/p&gt;<figure class="highlight plaintext">&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;<span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;<span class="line">ffmpeg -ss 60 -i presentation.aac -t 240 -c copy presentation_song.aac 好用</span><br><span class="line"></span><br><span class="line">ffmpeg -ss 60 -t 240 -i presentation.aac -c copy presentation_song.aac 不好用</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</figure>&lt;ul&gt;&lt;li&gt;&lt;p&gt;convert file format to <code>.ogg</code> with specififed sample rate: here we specified sample rate to be 44.1K &lt;/p&gt;<figure class="highlight bash">&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;<span class="line">1</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;<span class="line">ffmpeg -i input.wav -c:a libvorbis -ar 44100 output.ogg</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</figure>&lt;/li&gt;&lt;/ul&gt;<figure class="highlight plaintext">&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;<span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;<span class="line">ffmpeg -framerate 30 -i z_Blue1<em>1_60</em>%d.png -c:v libx264 -r 30 output.mp4</span><br><span class="line"></span><br><span class="line">for color in "Blue" "Red" "Green" "Yellow"; do for ((i=1; i&lt;=3; i++)); do printf "%s%d_1_60.png\n" "$color" "$i"; done; done</span><br><span class="line"></span><br><span class="line">ffmpeg -framerate 15 -i z_Blue1<em>1_60.png</em>%d.png -c:v libx264 -r 15 output.mp4</span><br><span class="line"></span><br><span class="line">记得看 aphelion-defense/assets/textures/60/test.sh</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</figure>&lt;h2 id="DaVinci"&gt;<a href="#DaVinci" class="headerlink" title="DaVinci"></a>DaVinci&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;<a href="https://www.youtube.com/watch?v=8lj7i-CvqTs" rel="external nofollow noopener" target="_blank">Import and Bake Subtitles in DaVinci</a> &lt;/li&gt;&lt;li&gt;<a href="https://www.youtube.com/watch?v=MiAPANZCopQ" rel="external nofollow noopener" target="_blank">Zoom In and Zoom Out in DaVinci</a>: achieve with key frames&lt;/li&gt;&lt;li&gt;<a href="https://www.youtube.com/watch?v=tzvNlGXXX5c" rel="external nofollow noopener" target="_blank">How to Fade in and Out Video</a> &lt;/li&gt;&lt;li&gt;<a href="https://www.youtube.com/watch?v=bQH8Z1WLA_w" rel="external nofollow noopener" target="_blank">Vertical timeline (Tiktok style)</a>&lt;/li&gt;&lt;li&gt;<a href="https://www.youtube.com/watch?v=E8Q2MhGw3wk" rel="external nofollow noopener" target="_blank">How to Control Audio Volume Levels</a>&lt;/li&gt;&lt;/ul&gt;&lt;h2 id="编码解码格式"&gt;<a href="#%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E6%A0%BC%E5%BC%8F" class="headerlink" title="编码解码格式"></a>编码解码格式&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;用 IDM 下载 YouTube 上视频会有两种格式 mkv 和 mp4 两种格式，结论：mkv 格式更优&lt;/p&gt;&lt;p&gt;都下载下来后使用 PotPlayer 播放时查看发现 &lt;/p&gt;&lt;ul&gt;&lt;li&gt;mkv 格式需要使用 FFmpeg libdav1d decoder&lt;/li&gt;&lt;li&gt;mp4 格式需要使用 FFmpeg h264 decoder &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;使用 ffprobe 发现&lt;/p&gt;&lt;ul&gt;&lt;li&gt;mkv 格式使用 av1 格式编码&lt;/li&gt;&lt;li&gt;mp4 格式使用 h264 格式编码&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;查询<a href="https://www.cnblogs.com/eguid/p/16015446.html" rel="external nofollow noopener" target="_blank">资料</a>得知 av1 是谷歌新发布的编解码规范，相比 h265 压缩优势都很大，就不用说 h264 了。IDM 官方也推荐使用 av1 编码的 mkv 格式。（官方FAQ: <a href="https://www.internetdownloadmanager.com/register/new_faq/bi28.html" rel="external nofollow noopener" target="_blank">Can I download MP4 instead of MKV or what should I do to play MKV videos correctly?</a> | <a href="https://www.internetdownloadmanager.com/register/new_faq/video15.html" rel="external nofollow noopener" target="_blank">I cannot play downloaded MKV video. What should I do?</a>）&lt;/p&gt;&lt;p&gt;One caveat: Google seems to be using vp9 as the encoder of live stream, but this is still better than h264 in mp4. &lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对于 SNH48 公演录播源，发现官网源使用 h264 ts 编码，YouTube 源大概是单独推流，谷歌编码为 vp9，且 YouTube 源有 1080P，官网只有720P。故优先选择 YouTube 源 （但是后来发现 YouTube 源好像音频是 opus 格式，Davinci 识别不了，最后用的还是别人的 bilibili 源）&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</p> </body></html>