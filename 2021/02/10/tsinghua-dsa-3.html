<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <p>CST数据结构（2020秋）PA3</p> <p><span id="more"></span>&lt;h2 id="3-1-Not-Found"&gt;<a href="#3-1-Not-Found" class="headerlink" title="3.1 Not Found"></a>3.1 <a href="/pdf/Tsinghua_DSA/3-1.pdf">Not Found</a>&lt;/h2&gt;&lt;h3 id="算法"&gt;<a href="#%E7%AE%97%E6%B3%95" class="headerlink" title="算法"></a>算法&lt;/h3&gt;&lt;p&gt;要找二进制字符串 A 中最短的未出现过的子串 B，我们先考虑一个比较长的子串，其长度为 24。 注意到 A 的长度最长为 16777216 = 2^24。因为还要掐头去尾，所以 A 中长度为 24 的子串的总数必定小于 2^24 个，而长度为 24 的字符串总共有 2^24 种，所以 A 中必定有某个长度为 24 的字符串是不存在的。&lt;/p&gt;&lt;p&gt;我们用 bitmap 边读入，边记录下所有出现过的长为 24 的子串。这个 bitmap 只存长度为 24 的子串，我们叫它 bitmap24。读入完成后，注意到任何一个在 A 中出现的长为 23 的子串必定是某一 24 子串掐头或去尾得到的，于是我们遍历所有在 24 子串，对他们掐头去尾，将得到的两个结果存入 bitmap23 中，如此做直到 bitmap1 存完。&lt;/p&gt;&lt;p&gt;最后我们从长度 24 开始遍历，找到<strong>第一个</strong>长度 n 使得所有长度为 n 的子串都在 A 中出现了，那么所要找的“最短未出现子串” B 必然有长度 n+1，我们只需要再遍历一遍 bitmap(n+1) 找到第一个不存在的字符串即可&lt;/p&gt;&lt;h3 id="细节"&gt;<a href="#%E7%BB%86%E8%8A%82" class="headerlink" title="细节"></a>细节&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;读入字符串的时候当总长度达到 24 以后，我们就要读一个新的弃一个旧的，因为根据题目分析 B 最长也就是 24&lt;/li&gt;&lt;li&gt;一个 int 是 4 byte = 32 bit = 2^5 bit，所以 bitmap24 需要 $2^{24}/2^5 = 2^{19}$ 个 int，bitmap1 … bitmap 5 各自仅需 1个 int&lt;/li&gt;&lt;li&gt;因为我们是将二进制字符串用 int 方式存在 bitmap 中，如果这个字符串有 leading 0s, 它们在输出时会被忽略掉，所以我们需要根据 bitmap-n 这个长度 n 来补全 leading 0s&lt;/li&gt;&lt;/ol&gt;&lt;h3 id="代码"&gt;<a href="#%E4%BB%A3%E7%A0%81" class="headerlink" title="代码"></a>代码&lt;/h3&gt;<figure class="highlight cpp">&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;<span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;<span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int_size[i] is the number of ints needed to store all strings of length i</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> int_size[<span class="number">25</span>] = {</span><br><span class="line"> <span class="number">1</span>, <span class="comment">// there should be no bitmap for string of length 0,</span></span><br><span class="line"> <span class="comment">// but we give it 1 to make the whole program consistent</span></span><br><span class="line"> <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="comment">// 2^1 2^2 2^3 2^4 2^5 each only needs one int</span></span><br><span class="line"> <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="comment">// 2^6, … 10</span></span><br><span class="line"> <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">512</span>,</span><br><span class="line"> <span class="number">1024</span>, <span class="number">2048</span>, <span class="number">4096</span>,</span><br><span class="line"> <span class="number">8192</span>, <span class="number">16384</span>, <span class="number">32768</span>,</span><br><span class="line"> <span class="number">65536</span>, <span class="number">131072</span>,</span><br><span class="line"> <span class="number">262144</span>, <span class="number">524288</span> };</span><br><span class="line"></span><br><span class="line"><span class="comment">// ones[i] is 2^i - 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ones[<span class="number">25</span>] = {</span><br><span class="line"> <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">31</span>,</span><br><span class="line"> <span class="number">63</span>, <span class="number">127</span>, <span class="number">255</span>, <span class="number">511</span>, <span class="comment">//10</span></span><br><span class="line"> <span class="number">1023</span>, <span class="number">2047</span>, <span class="number">4095</span>,</span><br><span class="line"> <span class="number">8191</span>, <span class="number">16383</span>, <span class="number">32767</span>,</span><br><span class="line"> <span class="number">65535</span>, <span class="number">131071</span>,</span><br><span class="line"> <span class="number">262143</span>, <span class="number">524287</span>, <span class="comment">//20</span></span><br><span class="line"> <span class="number">1048575</span>, <span class="number">2097151</span>,</span><br><span class="line"> <span class="number">4194303</span>, <span class="number">8388607</span>, <span class="number">16777215</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// bitmap[i] is the bitmap for binary strings of length i</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> *bitmap[<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// make our bitmap contain a binary string x of length n</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// returns true if our bitmap contains a binary string x of length n</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkbit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// print a binary string x of length n</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_binary</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">24</span>; i++) {</span><br><span class="line"> bitmap[i] = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>[int_size[i]];</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; int_size[i]; j++)</span><br><span class="line"> bitmap[i][j] = <span class="number">0</span>;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="comment">// n is the total number of characters we read in</span></span><br><span class="line"> <span class="comment">// s is the string at our sliding window</span></span><br><span class="line"> <span class="comment">// c is the character we just read in</span></span><br><span class="line"> <span class="comment">// input is 0 if c is '0', is 1 if c is '1'</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> n = <span class="number">0</span>, s = <span class="number">0</span>, input = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">char</span> c = <span class="built_in">getchar</span>(); n = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// read till nothing more to read or the string is 24 char long</span></span><br><span class="line"> <span class="keyword">for</span> (; c!=<span class="string">'\n'</span> &amp;&amp; n&lt;<span class="number">24</span>; c = <span class="built_in">getchar</span>()) {</span><br><span class="line"> input = c - <span class="string">'0'</span>;</span><br><span class="line"> s = (s &lt;&lt; <span class="number">1</span>) | input;</span><br><span class="line"> n += <span class="number">1</span>;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="comment">// n is the number of characters read in, including the line feed</span></span><br><span class="line"> <span class="comment">// n-1 is the actual length of s</span></span><br><span class="line"> <span class="built_in">setbit</span>(n<span class="number">-1</span>, s);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// we probably halted because n==24, so we read in 24 valid 0 1 characters</span></span><br><span class="line"> <span class="comment">// If so, there can be more to be read, so we try to read more but keep the string at 24 characters long</span></span><br><span class="line"> <span class="comment">// skip this loop if the string is finished with a space</span></span><br><span class="line"> <span class="keyword">for</span> (; c!=<span class="string">'\n'</span>; c = <span class="built_in">getchar</span>()) {</span><br><span class="line"> input = c - <span class="string">'0'</span>;</span><br><span class="line"> s = (s &lt;&lt; <span class="number">1</span>) | input;</span><br><span class="line"> s = s &amp; <span class="number">0xFFFFFF</span>; <span class="comment">// keeps only the first 24 characters</span></span><br><span class="line"> <span class="built_in">setbit</span>(<span class="number">24</span>, s);</span><br><span class="line"> n += <span class="number">1</span>;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> n -= <span class="number">1</span>; <span class="comment">// n is the number of characters read in, including the line feed</span></span><br><span class="line"> <span class="comment">// delete 1 to obtain the actual string length</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// len is the length of answer string</span></span><br><span class="line"> <span class="comment">// ans is the binary string in int representation</span></span><br><span class="line"> <span class="comment">// full is true if all the strings of length i is in our bitmap</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">bool</span> full = <span class="literal">false</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = n&gt;<span class="number">24</span> ? <span class="number">24</span> : n; i&gt;<span class="number">0</span> &amp;&amp; !full; i–) {</span><br><span class="line"> full = <span class="literal">true</span>; <span class="comment">// we assume this level is full</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ones[i] + <span class="number">1</span>; j++) { <span class="comment">// iterate all strings 0 ~ 2^i</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">checkbit</span>(i, j)) { <span class="comment">// percolate down to its substring</span></span><br><span class="line"> <span class="built_in">setbit</span>(i - <span class="number">1</span>, j &gt;&gt; <span class="number">1</span>);</span><br><span class="line"> <span class="built_in">setbit</span>(i - <span class="number">1</span>, j &amp; ones[i - <span class="number">1</span>]);</span><br><span class="line"> }</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (full) { <span class="comment">// current substring doesn't exist, and all the previous substrings do exist</span></span><br><span class="line"> <span class="comment">// so this is the FIRST substring that doesn't exist</span></span><br><span class="line"> ans = j;</span><br><span class="line"> len = i;</span><br><span class="line"> full = <span class="literal">false</span>;</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="built_in">print_binary</span>(len, ans);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span> </span>{</span><br><span class="line"> <span class="comment">// x%32 就是存储 x 的 bit，即从左向右 x%32 个位置的那个 bit</span></span><br><span class="line"> <span class="comment">// 但由于计算机中存储数是从右向左存的，我们需要让 1 从右端开始移动 ( 31- x%32 ) 个位置才可以</span></span><br><span class="line"> <span class="comment">// 这样我们得到一个第 x%32 为1，其他位为 0 的二进制数，通过 or 与原 bitmap 储值合并</span></span><br><span class="line"> <span class="comment">// bitmap[x/32] |= (1&lt;&lt;(31 - x%32));</span></span><br><span class="line"> bitmap[n][x&gt;&gt;<span class="number">5</span>] |= (<span class="number">1</span>&lt;&lt;(<span class="number">31</span> - x&amp;<span class="number">31</span>));</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkbit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span> </span>{</span><br><span class="line"> <span class="comment">// bitmap[x/32] &amp; (1&lt;&lt;(31 - x%32)) is determined solely by the x%32 bit of this int chunk</span></span><br><span class="line"> <span class="comment">// If that bit is 0, the whole expression is 0</span></span><br><span class="line"> <span class="comment">// If that bit is 1, the whole expression is greater than 1 and thus evaluate to true</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// return bitmap[x/32] &amp; (1&lt;&lt;(31 - x%32));</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> bitmap[n][x&gt;&gt;<span class="number">5</span>] &amp; (<span class="number">1</span>&lt;&lt;(<span class="number">31</span> - x&amp;<span class="number">31</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_binary</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span> </span>{</span><br><span class="line"> <span class="comment">// int 是从右往左存的，且我们只能访问最右边的 least-significant digit</span></span><br><span class="line"> <span class="comment">// 我们要从左往右打印，只能将从右向左的每个 bit 顺序存起来再倒序打印</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> ans[<span class="number">25</span>]; <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> (x != <span class="number">0</span>) {</span><br><span class="line"> ans[m] = x &amp; <span class="number">1</span>;</span><br><span class="line"> x = x &gt;&gt; <span class="number">1</span>;</span><br><span class="line"> m++;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 补全 leading 0s</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt; n; i++) {</span><br><span class="line"> ans[i] = <span class="number">0</span>;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i–) {</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans[i]);</span><br><span class="line"> }</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</figure>&lt;h3 id="复杂度分析"&gt;<a href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90" class="headerlink" title="复杂度分析"></a>复杂度分析&lt;/h3&gt;&lt;p&gt;读入长度为 n 的字符串，耗时 O(n)&lt;/p&gt;&lt;p&gt;如果 n &gt;24 则从 bitmap24 开始遍历，如果 n&lt;=24 则从 bitmap(n) 开始遍历，耗时 $O(2^{min(24,n)})$ &lt;/p&gt;&lt;p&gt;当 n 达到 2^24 级别时，整体复杂度还是 O(n)&lt;/p&gt;&lt;h3 id="Reference"&gt;<a href="#Reference" class="headerlink" title="Reference"></a>Reference&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;<a href="https://blog.csdn.net/onever_say_love/article/details/50908985" rel="external nofollow noopener" target="_blank">用C++实现bitmap</a>&lt;/li&gt;&lt;/ol&gt;&lt;h2 id="3-3-Kth"&gt;<a href="#3-3-Kth" class="headerlink" title="3.3 Kth"></a>3.3 <a href="/pdf/Tsinghua_DSA/3-3.pdf">Kth</a>&lt;/h2&gt;&lt;h3 id="算法-1"&gt;<a href="#%E7%AE%97%E6%B3%95-1" class="headerlink" title="算法"></a>算法&lt;/h3&gt;&lt;p&gt;题目要求找出 a,b,c 三个数组对应的三元数对中和为第 k 大的那个三元数对，观察到如果 a,b,c 是有序数对，那么必有 <code>a[i]+b[j]+c[k] &lt; a[i+1]+b[j]+c[k]</code>, <code>a[i]+b[j]+c[k] &lt; a[i]+b[j+1]+c[k]</code>, <code>a[i]+b[j]+c[k] &lt; a[i]+b[j]+c[k+1]</code>. &lt;/p&gt;&lt;p&gt;于是，我们维护一个优先队列，每次出队 <code>(i,j,k)</code> 就入队 <code>(i+1,j,k) (i,j+1,k) (i,j,k+1)</code>。如此做 k 次，出队的就是我们要找的三元对。我们现在将“找第 k 大”转变成了一个三维图的遍历问题。&lt;/p&gt;&lt;p&gt;实现中要注意的是不能让同一个点多次入队，我们可以开一个 vis 数组，但是每个数组最多有 500000 个元素，三维 vis 数组空间绝对不够。于是我们想一种遍历顺序，使得每个点只被遍历一次。首先考虑最简单的一维，单个的 x 轴，就是不停地遍历下一个而已 <code>i, i+1, i+2, ...</code> ；扩展到二维其实就是多个一维情况，我们通过 <code>(0,j), (1,j), ... (i-1,j)</code> 到达 <code>(i,j)</code> 那我们如何到达 <code>(0,j)</code> 呢？通过 <code>(0,0)</code> 的一维扩张，也就是说，当 x 轴为 0 时，我们既向 x 方向扩张，也向 y 方向扩张，而当 x 轴不为 0 时，我们只向 x 方向扩张。&lt;/p&gt;&lt;p&gt;对于三维情况，想象 x,y,z 正方向为右，前，下。则在任意时刻，我们都向 x 扩张；仅当 x=0 时，我们向 y 方向扩张；仅当 x=0 且 y=0 时，我们向 z 方向扩张。并且由于我们根据优先级选取每一次的扩张边界，我们一定也是优先级最高的先被找到。&lt;/p&gt;&lt;h3 id="细节-1"&gt;<a href="#%E7%BB%86%E8%8A%82-1" class="headerlink" title="细节"></a>细节&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;Heap 的实现：<code>sink</code> 时首先判断孩子存不存在（孩子坐标与元素总数比较）如果左孩子存在且“右孩子不存在，或左孩子优先级比右孩子高”，则与左孩子互换；如果右孩子存在且右孩子优先级更高，则与右孩子互换&lt;/li&gt;&lt;li&gt;三维的遍历顺序：尝试向 y 方向扩张时，如果 <code>x!=0</code>，跳过此次扩张；尝试向 z 方向扩张时，如果 <code>x!=0 || y!=0</code>，跳过此次扩张&lt;/li&gt;&lt;li&gt;数组的排序：在本题提供接口中，我们无法直接访问数组 a,b,c 中的元素，所以我们自己开另外三个数组 s,u,t 其中 s[i] 表示 a 中第 i 大的元素所对应在 a 中的位置。即 s,u,t 存 1…n， 代表 a,b,c 中的下标。为取得 s，我们使用 <code>sort(s,n)</code> 但比较器用的却是 a 的比较器&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="代码-1"&gt;<a href="#%E4%BB%A3%E7%A0%81-1" class="headerlink" title="代码"></a>代码&lt;/h3&gt;<figure class="highlight cpp">&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;<span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;<span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kth.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500007</span>, K = <span class="number">2000003</span>;</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">3</span>][<span class="number">3</span>] = { {<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>}, {<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>}, {<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>} };</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort x-axis by only comparing sums along x-axis</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sortx_cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>* b)</span> </span>{</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">compare</span>(<em>(<span class="keyword">int</span></em>)a, <span class="number">1</span>, <span class="number">1</span>, <em>(<span class="keyword">int</span></em>)b, <span class="number">1</span>, <span class="number">1</span>) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">compare</span>(<em>(<span class="keyword">int</span></em>)b, <span class="number">1</span>, <span class="number">1</span>, <em>(<span class="keyword">int</span></em>)a, <span class="number">1</span>, <span class="number">1</span>) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sorty_cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>* b)</span> </span>{</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">compare</span>(<span class="number">1</span>, <em>(<span class="keyword">int</span></em>)a, <span class="number">1</span>, <span class="number">1</span>, <em>(<span class="keyword">int</span></em>)b, <span class="number">1</span>) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">compare</span>(<span class="number">1</span>, <em>(<span class="keyword">int</span></em>)b, <span class="number">1</span>, <span class="number">1</span>, <em>(<span class="keyword">int</span></em>)a, <span class="number">1</span>) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sortz_cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>* b)</span> </span>{</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">compare</span>(<span class="number">1</span>, <span class="number">1</span>, <em>(<span class="keyword">int</span></em>)a, <span class="number">1</span>, <span class="number">1</span>, <em>(<span class="keyword">int</span></em>)b) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">compare</span>(<span class="number">1</span>, <span class="number">1</span>, <em>(<span class="keyword">int</span></em>)b, <span class="number">1</span>, <span class="number">1</span>, <em>(<span class="keyword">int</span></em>)a) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">triple</span> {</span></span><br><span class="line"> <span class="keyword">int</span> x, y, z;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">triple</span>() {</span><br><span class="line"> x = <span class="number">0</span>; y = <span class="number">0</span>; z = <span class="number">0</span>;</span><br><span class="line"> };</span><br><span class="line"></span><br><span class="line"> <span class="built_in">triple</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) {</span><br><span class="line"> x = a; y = b; z = c;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="built_in">triple</span>(<span class="keyword">const</span> triple&amp; from) {</span><br><span class="line"> <span class="keyword">this</span>-&gt;x = from.x;</span><br><span class="line"> <span class="keyword">this</span>-&gt;y = from.y;</span><br><span class="line"> <span class="keyword">this</span>-&gt;z = from.z;</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line"><span class="comment">// myPQ is my priority queue</span></span><br><span class="line">triple myPQ[K*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> triple INF = <span class="built_in">triple</span>(<span class="number">10e7</span>, <span class="number">10e7</span>, <span class="number">10e7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a, b, c is the array given in problem </span></span><br><span class="line"><span class="keyword">int</span> a[N], b[N], c[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> triple&amp; t1, <span class="keyword">const</span> triple&amp; t2) {</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">compare</span>(a[t1.x], b[t1.y], c[t1.z], a[t2.x], b[t2.y], c[t2.z]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> triple&amp; t1, <span class="keyword">const</span> triple&amp; t2) {</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">compare</span>(a[t2.x], b[t2.y], c[t2.z], a[t1.x], b[t1.y], c[t1.z]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// refactorred PQ that only uses strictly greater/lesser to be consistent with compare function</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span> {</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"> triple* a = myPQ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(triple x)</span></span></span><br><span class="line"><span class="function"> </span>{</span><br><span class="line"> a[++n] = x;</span><br><span class="line"> <span class="built_in">swim</span>(n);</span><br><span class="line"> }</span><br><span class="line"> <span class="function">triple <span class="title">extract</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>{</span><br><span class="line"> <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">throw</span> <span class="string">"Nothing to extract"</span>;</span><br><span class="line"> triple result = a[<span class="number">1</span>];</span><br><span class="line"> <span class="built_in">swap</span>(a[<span class="number">1</span>], a[n]);</span><br><span class="line"> a[n–] = INF;</span><br><span class="line"> <span class="built_in">sink</span>(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{ <span class="keyword">return</span> n == <span class="number">0</span>; }</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%d in heap: (%d, %d, %d)\n"</span>, i, ::a[a[i].x], b[a[i].y], c[a[i].z]);</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"> </span>{</span><br><span class="line"> <span class="keyword">while</span> (i &gt; <span class="number">1</span> &amp;&amp; !(a[i / <span class="number">2</span>] &lt; a[i])) {</span><br><span class="line"> <span class="built_in">swap</span>(a[i / <span class="number">2</span>], a[i]);</span><br><span class="line"> i = i / <span class="number">2</span>;</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"> </span>{</span><br><span class="line"> <span class="keyword">int</span> l = i * <span class="number">2</span>, r = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span> ((l &lt;= n &amp;&amp; !(a[i] &lt; a[l])) || (r &lt;= n &amp;&amp; !(a[i] &lt; a[r]))) {</span><br><span class="line"> <span class="keyword">if</span> (l &lt;= n &amp;&amp; (r &gt; n || !(a[l] &gt; a[r]))) { <span class="comment">// l is in the heap and (r is not in the heap, or l is the better choice compared to r)</span></span><br><span class="line"> <span class="built_in">swap</span>(a[i], a[l]);</span><br><span class="line"> i = l; l = i * <span class="number">2</span>; r = i * <span class="number">2</span> + <span class="number">1</span>; <span class="keyword">continue</span>;</span><br><span class="line"> }</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (a[l] &gt; a[r] &amp;&amp; r &lt;= n) {</span><br><span class="line"> <span class="built_in">swap</span>(a[i], a[r]);</span><br><span class="line"> i = r; l = i * <span class="number">2</span>; r = i * <span class="number">2</span> + <span class="number">1</span>; <span class="keyword">continue</span>;</span><br><span class="line"> }</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_kth</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> *x, <span class="keyword">int</span> *y, <span class="keyword">int</span> *z)</span> </span>{</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) {</span><br><span class="line"> a[i] = b[i] = c[i] = i;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="built_in">qsort</span>(a+<span class="number">1</span>, n, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), sortx_cmp);</span><br><span class="line"> <span class="built_in">qsort</span>(b+<span class="number">1</span>, n, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), sorty_cmp);</span><br><span class="line"> <span class="built_in">qsort</span>(c+<span class="number">1</span>, n, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), sortz_cmp);</span><br><span class="line"></span><br><span class="line"> PriorityQueue q;</span><br><span class="line"> q.<span class="built_in">add</span>(<span class="built_in">triple</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++) { <span class="comment">// extract k-1 triples</span></span><br><span class="line"> triple now = q.<span class="built_in">extract</span>();</span><br><span class="line"> <span class="keyword">int</span> nowx = now.x, nowy = now.y, nowz = now.z;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) {</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> nextx = nowx + dir[j][<span class="number">0</span>], nexty = nowy + dir[j][<span class="number">1</span>], nextz = nowz + dir[j][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (nextx &gt; n || nexty &gt; n || nextz &gt; n) <span class="keyword">continue</span>;</span><br><span class="line"> <span class="keyword">if</span> ((j == <span class="number">1</span> &amp;&amp; nowx != <span class="number">1</span>) || (j == <span class="number">2</span> &amp;&amp; (nowx != <span class="number">1</span> || nowy != <span class="number">1</span>))) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"> q.<span class="built_in">add</span>(<span class="built_in">triple</span>(nextx, nexty, nextz));</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line"> triple result = q.<span class="built_in">extract</span>();</span><br><span class="line"> *x = a[result.x];</span><br><span class="line"> *y = b[result.y];</span><br><span class="line"> *z = c[result.z];</span><br><span class="line">}</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</figure>&lt;h3 id="复杂度分析-1"&gt;<a href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1" class="headerlink" title="复杂度分析"></a>复杂度分析&lt;/h3&gt;&lt;p&gt;共有三个数组，一个数组中有 n 个元素，找大小为 k 对的三元数对。首先对三个数组进行排序 O(nlogn)，每有一个数对出优先队列，就有最多三个入优先队列，共操作 k 次，每次操作 O(logk)，总共 O(klogk)。总时间 O(nlogn + klogk)&lt;/p&gt;&lt;h2 id="3-4-Component"&gt;<a href="#3-4-Component" class="headerlink" title="3.4 Component"></a>3.4 <a href="/pdf/Tsinghua_DSA/3-4.pdf">Component</a>&lt;/h2&gt;&lt;h3 id="算法-2"&gt;<a href="#%E7%AE%97%E6%B3%95-2" class="headerlink" title="算法"></a>算法&lt;/h3&gt;&lt;p&gt;<strong>堆的合并 左偏树</strong>&lt;/p&gt;&lt;p&gt;题目的询问永远是某一联通分量中第 k 大的点的权值，k 是一个常数。第 k 大又可以看做前 k 个最大元素中最小的元素，即如果我们维护一个小根堆，使它恒有 k 个元素（n&lt;k 时输出 -1，n&gt;k 时弹出 n-k 次最小的元素）那么这 k 个元素必然是连通块中前 k 大的元素，堆顶元素就是我们的询问。&lt;/p&gt;&lt;p&gt;当加入的新边 (u,v) 联通两个不曾联通的连通块时，对应的两个堆必须合并。支持快速合并操作的优先队列，我们选择左式堆。(u,v) 将块联通，实际上是将其<strong>所在的</strong>堆合并起来，我们必须能够高效找到 (u,v) 所属哪个堆，即其所属堆的根是谁，使用并查集存储这个信息。&lt;/p&gt;&lt;h3 id="细节-2"&gt;<a href="#%E7%BB%86%E8%8A%82-2" class="headerlink" title="细节"></a>细节&lt;/h3&gt;&lt;p&gt;每个节点都有编号，我们不用传统的 class 建优先级队列，而直接用数组存每个点对应的信息，速度更快，访问更方便&lt;/p&gt;&lt;h3 id="代码-2"&gt;<a href="#%E4%BB%A3%E7%A0%81-2" class="headerlink" title="代码"></a>代码&lt;/h3&gt;<figure class="highlight cpp">&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;<span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;<span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> DEBUG = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000007</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k, q;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We use a min-heap 小根堆 to store the points</span></span><br><span class="line"><span class="comment">// delMax getMax refers to the "max priority" element, which has the smallest value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// value[i] is the value of the point i</span></span><br><span class="line"><span class="comment">// father[i] is the root of the heap i belongs to</span></span><br><span class="line"><span class="comment">// lchild[i], rchild[i] is the left and right child of the point i in heap</span></span><br><span class="line"><span class="comment">// npl[i] is the null-path-length of heap i</span></span><br><span class="line"><span class="comment">// sze[i] is the size of heap i</span></span><br><span class="line"><span class="keyword">int</span> value[N], father[N], lchild[N], rchild[N], npl[N], sze[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// find(i) returns the root of the heap i belongs to</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line"> <span class="keyword">return</span> x == father[x] ? x : (father[x] = <span class="built_in">find</span>(father[x]));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// merge heap b into heap a</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line"> <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line"> <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line"> <span class="keyword">if</span> (value[a] &gt; value[b]) <span class="built_in">swap</span>(a,b);</span><br><span class="line"></span><br><span class="line"> rchild[a] = <span class="built_in">merge</span>(rchild[a], b);</span><br><span class="line"> father[rchild[a]] = <span class="built_in">find</span>(a);</span><br><span class="line"> <span class="keyword">if</span> (lchild[a] == <span class="number">0</span> || npl[lchild[a]] &lt; npl[rchild[a]]) {</span><br><span class="line"> <span class="keyword">int</span> temp = lchild[a];</span><br><span class="line"> lchild[a] = rchild[a];</span><br><span class="line"> rchild[a] = temp;</span><br><span class="line"> }</span><br><span class="line"> npl[a] = rchild[a] == <span class="number">0</span> ? <span class="number">1</span> : npl[rchild[a]] + <span class="number">1</span>;</span><br><span class="line"> sze[a] = sze[lchild[a]] + sze[rchild[a]] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// getMax(x) returns the value of root of the heap x represents</span></span><br><span class="line"><span class="comment">// Requires: x is the root of a heap</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line"> <span class="comment">// x is the root, root is the max, so we just return the value of x</span></span><br><span class="line"> <span class="keyword">return</span> value[x];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// delMax(x) returns the new root after deleting root in heap x</span></span><br><span class="line"><span class="comment">// Requires: x is the root of a heap</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delMax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line"> <span class="keyword">int</span> ans = value[x];</span><br><span class="line"> sze[x] -= <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">int</span> new_root = <span class="built_in">merge</span>(lchild[x], rchild[x]);</span><br><span class="line"> father[new_root] = new_root; <span class="comment">// new root is now a root, so its father is itself</span></span><br><span class="line"> father[x] = new_root; <span class="comment">// this deleted node, and all the nodes pointing to the deleted node should now point to the new root</span></span><br><span class="line"> <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// deletes the Max element until this heap has no more than k elements</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prune</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line"> <span class="keyword">if</span> (sze[x] &lt;= k) <span class="keyword">return</span>;</span><br><span class="line"> <span class="built_in">delMax</span>(<span class="built_in">find</span>(x)); <span class="comment">// needs to find(x) because delMax requires a root</span></span><br><span class="line"> <span class="built_in">prune</span>(<span class="built_in">find</span>(x)); <span class="comment">// after being deleted, x becomes a stranded point</span></span><br><span class="line"> <span class="comment">// prune must take in the new root of the heap</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// print all points and their information</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="keyword">if</span> (!DEBUG) <span class="keyword">return</span>;</span><br><span class="line"> cout &lt;&lt; <span class="string">"# value Parent Lchild Rchild npl size "</span> &lt;&lt; endl;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; i;</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; value[i];</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; father[i];</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; lchild[i];</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; rchild[i];</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; npl[i];</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; sze[i];</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;k, &amp;q);</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">"%d"</span>, value + i);</span><br><span class="line"> father[i] = i;</span><br><span class="line"> lchild[i] = rchild[i] = npl[i] = <span class="number">0</span>; <span class="comment">// points to null</span></span><br><span class="line"> sze[i] = <span class="number">1</span>;</span><br><span class="line"> } sze[<span class="number">0</span>] = <span class="number">0</span>; npl[<span class="number">0</span>] = <span class="number">0</span>; father[<span class="number">0</span>] = lchild[<span class="number">0</span>] = rchild[<span class="number">0</span>] = <span class="number">10e9</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line"> <span class="keyword">int</span> a, b;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="keyword">continue</span>; <span class="comment">// already connected, another edge doesn't make a difference</span></span><br><span class="line"> <span class="keyword">int</span> merged = <span class="built_in">merge</span>(<span class="built_in">find</span>(a), <span class="built_in">find</span>(b));</span><br><span class="line"> <span class="built_in">prune</span>(merged);</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) {</span><br><span class="line"> <span class="keyword">int</span> op, a, b;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;op);</span><br><span class="line"> <span class="keyword">if</span> (op == <span class="number">1</span>) {</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="keyword">continue</span>;</span><br><span class="line"> <span class="keyword">int</span> merged = <span class="built_in">merge</span>(<span class="built_in">find</span>(a), <span class="built_in">find</span>(b));</span><br><span class="line"> <span class="built_in">prune</span>(merged);</span><br><span class="line"> }</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) {</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line"> <span class="keyword">if</span> (sze[<span class="built_in">find</span>(a)] &lt; k) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line"> <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">getMax</span>(<span class="built_in">find</span>(a)));</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">}</span><br>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</figure>&lt;h3 id="复杂度分析-2"&gt;<a href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-2" class="headerlink" title="复杂度分析"></a>复杂度分析&lt;/h3&gt;&lt;p&gt;初始化后，每个点最多被入堆一次（所在连通块与他人联通），出堆一次（因为不属于前 k 大而被弹出堆）每次出入堆操作是两个左式堆的 merge，复杂度 O(logn)。共 n 个点，所以总体复杂度是 O(n logn)&lt;/p&gt;&lt;h3 id="Reference-1"&gt;<a href="#Reference-1" class="headerlink" title="Reference"></a>Reference&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;<a href="https://www.luogu.com.cn/blog/hsfzLZH1/solution-p3377" rel="external nofollow noopener" target="_blank">题解 P3377 【模板】左偏树(可并堆)</a>&lt;/li&gt;&lt;li&gt;<a href="http://dsa.cs.tsinghua.edu.cn/~deng/ds/src_link/pq_leftheap/pq_leftheap.h.htm" rel="external nofollow noopener" target="_blank">课程代码</a>&lt;/li&gt;&lt;/ol&gt;</p> </body></html>